<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕楠椿</title>
  
  
  <link href="https://munanchun.github.io/atom.xml" rel="self"/>
  
  <link href="https://munanchun.github.io/"/>
  <updated>2024-06-09T16:00:00.000Z</updated>
  <id>https://munanchun.github.io/</id>
  
  <author>
    <name>慕楠椿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>requestAnimationFrame与requestIdleCallback</title>
    <link href="https://munanchun.github.io/posts/16a57e6f.html"/>
    <id>https://munanchun.github.io/posts/16a57e6f.html</id>
    <published>2024-06-09T16:00:00.000Z</published>
    <updated>2024-06-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><h3 id="0-浏览器渲染帧"><a href="#0-浏览器渲染帧" class="headerlink" title="0 浏览器渲染帧"></a>0 浏览器渲染帧</h3><p>如图代表一个时间轴，浏览器会每隔一小段时间把页面重新画一遍，把这个过程称之为渲染，间隔的时间点，称之为渲染帧，通常情况下，1 秒钟 60 帧（1 秒钟浏览器把页面画 60 遍）</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/75.webp" /></div><p>如果用<code>js</code>计时器去做动画，可以精确的设置间隔时间，保证两个渲染帧之间，刚好夹一个动画操作（改变尺寸，位置等），好处在于，每一次改变之后就马上可以得到渲染，但是这一切都是理想的情况。</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/65.webp" /></div><p>实际情况：渲染帧分布的没有那么平均，如下图所示。受影响的因素有很多，如机械配置等原因。</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/66.webp" /></div><p>就会导致，有些地方，两个渲染帧之间没有做任何动画，即 <code>空帧</code>（现在画了，但是跟之前画的一模一样，但是还是白画了一遍，没有在两个渲染帧之间做出任何动画操作，就造成了<code>渲染帧的浪费</code>）</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/67.webp" /></div><p>同时，也会存在<code>跳帧</code>，两个渲染帧之间出现了多次动画（两个渲染帧之间，改变了两次位置，代码运行了，但是最后只渲染了一次，只是第二次的改变），页面上会感觉跳了一下，会导致<code>动画不连续</code></p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/68.webp" /></div><p>但是以上还是比较理想的情况，实际的情况更为复杂，比如你写的计时器 16 毫秒间隔，但是真的是 16 毫秒吗？</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/69.webp" /></div><p>这样一来，<code>跳帧</code>、<code>空帧</code>就会非常严重。</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/70.webp" /></div><p>此时，便引出了本文的重点：<code>requestAnimationFrame</code></p><h3 id="1-1-官方定义"><a href="#1-1-官方定义" class="headerlink" title="1.1 官方定义"></a>1.1 官方定义</h3><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/71.webp" /></div><h3 id="1-2-关于前端动画"><a href="#1-2-关于前端动画" class="headerlink" title="1.2 关于前端动画"></a>1.2 关于前端动画</h3><h4 id="1-2-1-前端动画方案目前有哪些？"><a href="#1-2-1-前端动画方案目前有哪些？" class="headerlink" title="1.2.1 前端动画方案目前有哪些？"></a>1.2.1 前端动画方案目前有哪些？</h4><ul><li><p><code>css</code>动画</p><ul><li><code>transition</code>：过渡动画</li><li><code>animation</code>：直接动画（搭配<code>@keyframes</code>）</li></ul></li><li><p><code>js</code>动画</p><ul><li><code>setInterval</code>或<code>setTimeout</code>定时器（比如不停地更改<code>dom元素</code>的位置，使其运动起来）</li><li><code>canvas</code>动画，搭配<code>js</code>中的定时器去运动起来（<code>canvas</code>只是一个画笔，然后我们通过定时器会使用这个画笔去画画-动画）</li><li><code>requestAnimationFrame动画（js动画中的较好方案）</code></li></ul></li></ul><h4 id="1-2-2-为何要使用这个-api-来做动画？"><a href="#1-2-2-为何要使用这个-api-来做动画？" class="headerlink" title="1.2.2 为何要使用这个 api 来做动画？"></a>1.2.2 为何要使用这个 api 来做动画？</h4><p>在工作中，做动画最优的方案无疑是<code>css动画</code>，但是某些特定场景下，<code>css动画</code>无法实现我们所需要的需求。这时，我们就要考虑使用<code>js</code>去做动画了，<code>canvas动画</code>的<code>本质</code>也是<code>定时器动画</code>。使用定时器动画干活，实际上是可以的，但是存在一个最大的问题，就是如上文所讲到<code>动画会抖动</code>，体验效果不是非常好。</p><p>而使用<code>requestAnimationFrame</code>去做动画，就不会出现抖动的现象。</p><p>这里写了一个 demo 实现的效果图（gif 看着效果不太好，建议复制代码自己试一试）</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/72.gif" /></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      * &#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 滚动条平滑滚动 */</span></span></span><br><span class="line"><span class="language-css">        scroll-behavior: smooth;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.a</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.b</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-top</span>: <span class="number">70px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>走起<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> a = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> b = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.b&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> x = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> y = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">setIntervalFn</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        x++;</span></span><br><span class="line"><span class="language-javascript">        a.<span class="property">style</span>.<span class="property">left</span> = x + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">16</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">raf</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        y++;</span></span><br><span class="line"><span class="language-javascript">        b.<span class="property">style</span>.<span class="property">left</span> = y + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">raf</span>();</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 动画绑定</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.btn&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      setIntervalFn();</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">raf</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-语法规则"><a href="#1-3-语法规则" class="headerlink" title="1.3 语法规则"></a>1.3 语法规则</h3><p><code>requestAnimationFrame</code>和<code>js</code>中的<code>setTimeout</code>定时器函数<code>基本一致</code>，不过<code>setTimeout</code>可以自由设置间隔时间，而<code>requestAnimationFrame</code>的间隔时间是由浏览器自身决定的，大约是<code>17毫秒</code>左右</p><ol><li><code>requestAnimationFrame</code>我们可以在控制台输入<code>window</code>，然后展开查看其身上的属性，就能找到了</li><li><code>requestAnimationFrame</code>本质上是一个全局<code>window</code>对象上的一个属性函数，所以我们使用时，直接：<code>window.requestAnimationFrame(callBack)</code>即可。</li><li>和定时器一样其接收的参数<code>callback</code>也是一个函数，即下一次重绘之前更新动画帧所调用的函数，即在这个函数体中，我们可以写对应的逻辑代码（和定时器类似）。</li><li>requestAnimationFrame 也有返回值，返回值是一个整数，主要是定时器的身份证标识，可以使用<code>window.cancelAnimationFrame()来取消回调函数执行</code>，相当于定时器中的<code>clearTimeout()</code>。</li><li>二者也都是只执行一次，想要继续执行，做到类似<code>setInterval</code>的效果，需要写成递归的形式（上述案例中也提到了）</li></ol><h3 id="1-4-关于卡顿的问题"><a href="#1-4-关于卡顿的问题" class="headerlink" title="1.4 关于卡顿的问题"></a>1.4 关于卡顿的问题</h3><h4 id="1-4-1-为什么定时器会卡"><a href="#1-4-1-为什么定时器会卡" class="headerlink" title="1.4.1 为什么定时器会卡"></a>1.4.1 为什么定时器会卡</h4><ul><li>我们在手机或者电脑显示屏上看东西时，显示屏会默默的不停地干活（刷新画面）</li><li>这个刷新值得是每秒钟刷新次数，普通显示器的刷新率约为 60Hz（每秒刷新 60 次），另外也有 75Hz、90Hz、120Hz、144Hz 等等</li><li>刷新率次数越高，显示器显示的图像越清晰、越流畅、越丝滑</li><li>不刷新就是静态的画面，刷新比较低就是<code>卡了</code>，<code>PPT</code>的感觉</li><li>动画想要丝滑流畅，需要卡住时间点进行代码操作（代码语句赋值、浏览器重绘）</li><li>所以只需要每隔 1000 毫秒的 60 分之一（60HZ）即约为 17 毫秒，进行一次动画操作即可</li><li>只要卡住这个 17 毫秒，每隔 17 毫秒进行操作，就能确保动画丝滑</li><li>但是定时器的回调函数，会受到<code>js</code>的事件队列宏任务、微任务影响，可能设定的是 17 毫秒执行一次，但是实际上这次是 17 毫秒、下次 21 毫秒、再下次 13 毫秒执行，所以并不是严格的卡住了这个 60HZ 的时间</li><li>没有在合适的时间点操作，就会出现：类似这样的情况：<code>变</code>、<code>不变</code>、<code>不变</code>、<code>变</code>、<code>不变</code>…</li><li>于是就出现了，绘制不及时的情况，就会有抖动的出现（以上述案例，位置和时间没有线性对应更新变化导致看起来抖动）</li></ul><h4 id="1-4-2-为何requestAnimationFrame不会卡"><a href="#1-4-2-为何requestAnimationFrame不会卡" class="headerlink" title="1.4.2 为何requestAnimationFrame不会卡"></a>1.4.2 为何<code>requestAnimationFrame</code>不会卡</h4><p><code>setTimeout</code>和<code>setInterval</code>的问题是，它们都不精确。它们的内在运行机制决定了时间间隔，参数实际上只是指定了把动画代码添加到浏览器<code>UI</code>线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。</p><p>而<code>requestAnimationFrame</code>是永远跟着渲染帧走的，无论渲染帧如何改变，始终保证在渲染帧之前始终有一个动画操作，既没有<code>空帧</code>也没有<code>跳帧</code>，从而保证了动画的流畅</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/73.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/74.webp" /></div><h3 id="1-5-应用场景"><a href="#1-5-应用场景" class="headerlink" title="1.5 应用场景"></a>1.5 应用场景</h3><p>例如：回到顶部 组件，就可以使用<code>requestAnimationFrame</code>API 去做，理论讲解完毕，该自行实践了（doge）</p><h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h2><h3 id="2-1-为什么需要-requestIdleCallback-？"><a href="#2-1-为什么需要-requestIdleCallback-？" class="headerlink" title="2.1 为什么需要 requestIdleCallback ？"></a>2.1 为什么需要 requestIdleCallback ？</h3><p>在网页中，有许多耗时但是却又不能那么紧要的任务。它们和紧要的任务，比如对用户的输入作出及时响应的之类的任务，它们共享事件队列。如果两者发生冲突，用户体验会很糟糕。我们可以使用<code>setTimout</code>，对这些任务进行延迟处理。但是我们并不知道，<code>setTimeout</code>在执行回调时，是否是浏览器空闲的时候。</p><p>而<code>requestIdleCallback</code>就解决了这个痛点，<code>requestIdleCallback</code>会在帧结束时并且有空闲时间。或者用户不与网页交互时，执行回调。</p><h3 id="2-2-API-简介"><a href="#2-2-API-简介" class="headerlink" title="2.2 API 简介"></a>2.2 API 简介</h3><ul><li><code>requestIdleCallback</code>的第一个参数时<code>callback</code><ul><li>当<code>callback</code>被调用时，回接受一个参数 <code>deadline</code>，<code>deadline</code>是一个对象，对象上有两个属性<ul><li><code>timeRemaining</code>，<code>timeRemaining</code>属性是一个函数，函数的返回值表示当前空闲时间还剩下多少时间</li><li><code>didTimeout</code>，<code>didTimeout</code>属性是一个布尔值，如果<code>didTimeout</code>是 true，那么表示本次 callback 的执行是因为超时的原因</li></ul></li></ul></li><li>r<code>equestIdleCallback</code>的第二个参数是 options<ul><li><code>options</code>是一个对象，可以用来配置超时时间</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">requestIdleCallback</span>(</span><br><span class="line">  <span class="function">(<span class="params">deadline</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// deadline.timeRemaining() 返回当前空闲时间的剩余时间</span></span><br><span class="line">    <span class="keyword">if</span> (deadline.<span class="title function_">timeRemaining</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">500</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-3-空闲时间"><a href="#2-3-空闲时间" class="headerlink" title="2.3 空闲时间"></a>2.3 空闲时间</h3><p><code>requestIdleCallback</code> 的 callback 会在浏览器的空闲时间运行，那么什么是空闲时间呢？</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/76.webp" /></div><p>如上图。当我们在执行一段连续的动画的时候，第一帧已经渲染到屏幕上了，到第二帧开始渲染，这段时间内属于空闲时间。这种空闲时间会非常的短暂，如果我们的屏幕是 60hz（1s 内屏幕刷新 60 次）的。那么空闲时间会小于 16ms（1000ms / 16）。</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/77.webp" /></div><p>另外一种空闲时间，当用户属于空闲状态（没有与网页进行任何交互），并且没有屏幕中也没有动画执行。此时空闲时间是无限长的。但是为了避免不可预测的事（用户突然和网页进行交互），空闲时间最大应该被限制在 50ms 以内。</p><blockquote><p>为什么最大是 50ms？人类对 100ms 内的响应会认为是瞬时的。将空闲时间限制在 50ms 以内，是为了避免，空闲时间内执行任务，从而导致了对用户操作响应的阻塞，使用户感到明显的响应滞后。</p></blockquote><p>在空闲期间，callback 的执行顺序是以 FIFO（先进先出）的顺序。但是如果在空闲时间内依次执行 callback 时，有一个 callback 的执行时间，已经将空闲时间用完了，剩下的 callback 将会在下一次的空闲时间执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">task1</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行任务1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">task2</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行任务2&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">task3</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行任务3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console</span></span><br><span class="line"><span class="comment">// 执行任务1</span></span><br><span class="line"><span class="comment">// 执行任务2</span></span><br><span class="line"><span class="comment">// 执行任务3</span></span><br><span class="line"><span class="title function_">requestIdleCallback</span>(task1);</span><br><span class="line"><span class="title function_">requestIdleCallback</span>(task2);</span><br><span class="line"><span class="title function_">requestIdleCallback</span>(task3);</span><br></pre></td></tr></table></figure><p>如果当前的任务所需要的执行时间，超过了当前空闲时间周期内的剩余时间，我们也可以将任务带到下一个空闲时间周期内执行。在下一个空闲周期开始后，新添加的 callback 会被添加到 callback 列表的末尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> startTask = (deadline) &#123;</span><br><span class="line">    <span class="comment">// 如果 `task` 花费的时间是20ms</span></span><br><span class="line">    <span class="comment">// 超过了当前空闲时间的剩余毫秒数，我们等到下一次空闲时间执行task</span></span><br><span class="line">    <span class="keyword">if</span> (deadline.<span class="title function_">timeRemaining</span>() &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="comment">// 将任务带到下一个空闲时间周期内</span></span><br><span class="line">        <span class="comment">// 添加到下一个空闲时间周期callback列表的末尾</span></span><br><span class="line">        <span class="title function_">requestIdleCallback</span>(startTask)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        <span class="title function_">task</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们网页处于不可见的状态时（比如切换到其他的 tag），我们空闲时间将会每 10s, 触发一次空闲期。</p><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>如果指定了 timeout，但是浏览器没有在 timeout 指定的时间内，执行 callback。在下次空闲时间时，callback 会强制执行。并且 callback 的参数，<code>deadline.didTimeout</code>等于 true, <code>deadline.timeRemaining()</code>返回 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">requestIdleCallback</span>(<span class="function">(<span class="params">deadline</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(deadline.<span class="property">didTimeout</span>)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">1000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个操作大概花费5000ms</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> + <span class="string">`&lt;p&gt;<span class="subst">$&#123;i&#125;</span>&lt;/p&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-常见-Q-amp-A"><a href="#2-4-常见-Q-amp-A" class="headerlink" title="2.4 常见 Q&amp;A"></a>2.4 常见 Q&amp;A</h3><p>Q1: <code>requestIdleCallback</code> 会在每一次帧结束时执行吗？</p><p>A1: 只会在帧末尾有空闲时间时会执行，不应该期望每一次帧结束都会执行<code>requestIdleCallback</code>。</p><p>Q2: 什么操作不适合放到 <code>requestIdleCallback</code> 的 callback 中。</p><p>A2: 更新 DOM，以及 Promise 的回调（会使帧超时），什么意思？请看下面的代码。<code>requestIdleCallback</code>中代码，应该是一些可以预测执行时间的小段代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console</span></span><br><span class="line"><span class="comment">// 空闲时间1</span></span><br><span class="line"><span class="comment">// 等待了1000ms</span></span><br><span class="line"><span class="comment">// 空闲时间2</span></span><br><span class="line"><span class="comment">// Promise 会在空闲时间1结束后立即执行，即使没有空闲时间了也是如此。拖延了进入下一帧的时间</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">requestIdleCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;空闲时间1&quot;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;等待了1000ms&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestIdleCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;空闲时间2&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">requestAnimationFrame与requestIdleCallback详解</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的垃圾回收机制</title>
    <link href="https://munanchun.github.io/posts/a9bfb9f7.html"/>
    <id>https://munanchun.github.io/posts/a9bfb9f7.html</id>
    <published>2024-04-08T16:00:00.000Z</published>
    <updated>2024-04-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>JavaScript 是门魅力无限的语言，关于它的 GC（垃圾回收）方面，你了解多少呢？想来大部分人是因为面试才去看一些面试题从而了解的垃圾回收，那在正式开始之前，给大家列几个小问题，大家可以先想一下答案，带着问题及答案再去看文章，最后读完此文如果你的答案可以优化，即有收获</p><ul><li>什么是垃圾回收机制？</li><li>垃圾是怎样产生的？</li><li>为什么要进行垃圾回收？</li><li>垃圾回收是怎样进行的？</li><li>V8 引擎对垃圾回收进行了哪些优化？</li></ul><h2 id="GC-是什么"><a href="#GC-是什么" class="headerlink" title="GC 是什么"></a>GC 是什么</h2><p><code>GC</code> 即 <code>Garbage Collection</code> ，程序工作过程中会产生很多 <code>垃圾</code>，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 <code>GC</code> 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，<code>GC</code> 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 <code>垃圾回收机制</code> 了</p><p>当然也不是所有语言都有 <code>GC</code>，一般的高级语言里面会自带 <code>GC</code>，比如 <code>Java、Python、JavaScript</code> 等，也有无 <code>GC</code> 的语言，比如 <code>C、C++</code> 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦</p><h2 id="垃圾产生-amp-为何回收"><a href="#垃圾产生-amp-为何回收" class="headerlink" title="垃圾产生&amp;为何回收"></a>垃圾产生&amp;为何回收</h2><p>我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的，但是我们并不关注这些，因为这是引擎为我们分配的，我们不需要显式手动的去分配内存</p><p>但是，你有没有想过，当我们不再需要某个东西时会发生什么？JavaScript 引擎又是如何发现并清理它的呢？</p><p>我们举个简单的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;isboyjc&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">test = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>如上所示，我们假设它是一个完整的程序代码</p><p>我们知道 <code>JavaScript</code> 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用，所以，<code>JavaScript</code> 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。可以简单理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的</p><p>那上面代码首先我们声明了一个变量 <code>test</code>，它引用了对象 <code>&#123;name: &#39;isboyjc&#39;&#125;</code>，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了，如下图</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/58.webp' /></div><p>没有了引用关系，也就是无用的对象，这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）。</p><p>用官方一点的话说，程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃。</p><h2 id="垃圾回收策略"><a href="#垃圾回收策略" class="headerlink" title="垃圾回收策略"></a>垃圾回收策略</h2><p>在 JavaScript 内存管理中有一个概念叫做 <code>可达性</code>，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收。</p><p>至于如何回收，其实就是怎样发现这些不可达的对象（垃圾）它并给予清理的问题， <strong><code>JavaScript</code> 垃圾回收机制的原理说白了也就是定期找出那些不再用到的内存（变量），然后释放其内存。</strong></p><p>你可能还会好奇为什么不是实时的找出无用内存并释放呢？其实很简单，实时开销太大了</p><p>我们都可以 Get 到这之中的重点，那就是怎样找出所谓的垃圾？</p><p>这个流程就涉及到了一些算法策略，有很多种方式，其中两个最常见的</p><ul><li>标记清除算法</li><li>引用计数算法</li></ul><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除（Mark-Sweep），目前在 <code>JavaScript引擎</code> 里这种算法是最常用的，到目前为止的大多数浏览器的 <code>JavaScript引擎</code> 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 <code>JavaScript引擎</code> 在运行垃圾回收的频率上有所差异。</p><p>就像它的名字一样，此算法分为 <code>标记</code> 和 <code>清除</code> 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。</p><p>首先它会遍历堆内存上所有的对象，分别给它们打上标记，然后在代码执行过程结束之后，对所使用过的变量取消标记。在清除阶段再把具有标记的内存对象进行整体清除，从而释放内存空间。</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/59.webp' /></div><p>整个标记清除算法大致过程就像下面这样</p><ul><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记</li><li>然后从各个根对象开始遍历，把还在被上下文变量引用的变量标记去掉标记</li><li>清理所有带有标牌机的变量，销毁并回收它们所占用的内存空间</li><li>最后垃圾回收程序做一次内存清理</li></ul><p>假设我们新建对象分配内存时需要大小为 <code>size</code>，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 <code>size</code> 的块才能为其分配（如下图）</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/60.webp' /></div><p>那如何找到合适的块呢？我们可以采取下面三种分配策略</p><ul><li><code>First-fit</code>，找到大于等于 <code>size</code> 的块立即返回</li><li><code>Best-fit</code>，遍历整个空闲列表，返回大于等于 <code>size</code> 的最小分块</li><li><code>Worst-fit</code>，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 <code>size</code> 大小，并将该部分返回</li></ul><p>这三种策略里面 <code>Worst-fit</code> 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 <code>First-fit</code> 和 <code>Best-fit</code> 来说，考虑到分配的速度和效率 <code>First-fit</code> 是更为明智的选择。</p><p>综上所述，标记清除算法或者说策略就有两个很明显的缺点</p><ul><li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块</li><li><strong>分配速度慢</strong>，因为即便是使用 <code>First-fit</code> 策略，其操作仍是一个 <code>O(n)</code> 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢</li></ul><p>归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了。</p><p>而 <strong>标记整理（Mark-Compact）算法</strong> 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/61.webp' /></div><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 <code>对象是否不再需要</code> 简化定义为 <code>对象有没有其他对象引用到它</code>，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下。</p><p>它的策略是跟踪记录每个变量值被使用的次数</p><ul><li>当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</li><li>如果同一个值又被赋给另一个变量，那么引用数加 1</li><li>如果该变量的值被其他的值覆盖了，则引用次数减 1</li><li>当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存</li></ul><p>如下例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// 此对象的引用计数为 1（a引用）</span></span><br><span class="line"><span class="keyword">let</span> b = a <span class="comment">// 此对象的引用计数是 2（a,b引用）</span></span><br><span class="line">a = <span class="literal">null</span>  <span class="comment">// 此对象的引用计数为 1（b引用）</span></span><br><span class="line">b = <span class="literal">null</span>  <span class="comment">// 此对象的引用计数为 0（无引用）</span></span><br><span class="line">...<span class="comment">// GC 回收此对象</span></span><br></pre></td></tr></table></figure><p>这种方式是不是很简单？确实很简单，不过在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> A = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">let</span> B = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">  A.<span class="property">b</span> = B;</span><br><span class="line">  B.<span class="property">a</span> = A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 <code>test</code> 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放。</p><p>我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一。</p><p><strong>优点</strong></p><p>引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾</p><p>而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS 脚本）运行过程中线程就必须要暂停去执行一段时间的 <code>GC</code>，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了</p><p><strong>缺点</strong></p><p>引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的</p><h2 id="V8-对于垃圾回收机制的优化"><a href="#V8-对于垃圾回收机制的优化" class="headerlink" title="V8 对于垃圾回收机制的优化"></a>V8 对于垃圾回收机制的优化</h2><p>大多数浏览器都是基于标记清除算法，不同的只是在运行垃圾回收的频率具有差异。V8 对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化。</p><h3 id="分代式垃圾回收"><a href="#分代式垃圾回收" class="headerlink" title="分代式垃圾回收"></a>分代式垃圾回收</h3><p>试想一下，我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了</p><h4 id="新老生代"><a href="#新老生代" class="headerlink" title="新老生代"></a>新老生代</h4><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收</p><p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 <code>1～8M</code> 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大</p><p>V8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/62.webp' /></div><p>对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了</p><h4 id="新生代垃圾回收"><a href="#新生代垃圾回收" class="headerlink" title="新生代垃圾回收"></a>新生代垃圾回收</h4><p>新生代对象是通过一个名为 <code>Scavenge</code> 的算法进行垃圾回收，在 <code>Scavenge算法</code> 的具体实现中，主要采用了一种复制式的方法即 <code>Cheney算法</code> ，我们细细道来</p><p><code>Cheney算法</code> 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 <code>使用区</code>，一个是处于闲置状态的空间我们称之为 <code>空闲区</code>，如下图所示</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/63.webp' /></div><ul><li>新加入的对象都会存放在使用区，当使用区快写满时就进行一次垃圾清理操作。</li><li>在开始进行垃圾回收时，新生代回收器会对使用区内的对象进行标记</li><li>标记完成后，需要对使用区内的活动对象拷贝到空闲区进行排序</li><li>而后进入垃圾清理阶段，将非活动对象占用的内存空间进行清理</li><li>最后对使用区和空闲区进行交换，使用区-&gt;空闲区，空闲区-&gt;使用区</li></ul><p>当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理</p><p>另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 <code>Scavenge</code> 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配</p><h4 id="老生代垃圾回收"><a href="#老生代垃圾回收" class="headerlink" title="老生代垃圾回收"></a>老生代垃圾回收</h4><p>相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了</p><p>首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象</p><p>清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉</p><p>前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间</p><h2 id="内存泄漏与优化"><a href="#内存泄漏与优化" class="headerlink" title="内存泄漏与优化"></a>内存泄漏与优化</h2><p>内存泄漏，指在 JS 中已经分配内存地址的对象由于长时间未进行内存释放或无法清除，造成了长期占用内存，使得内存资源浪费，最终导致运行的应用响应速度变慢以及最终崩溃的情况。</p><p>在代码中创建对象和变量时会占据内存，但是<strong>JS 基于自己的内存回收机制是可以确定哪些变量不再需要，并将其进行清除</strong>。但是，当你的代码中存在逻辑缺陷时，你以为你已经不需要，但是程序中还存在这引用，这就导致程序运行完后并没有进行合适的回收所占有的内存空间。运行时间越长占用内存越多，随之出现的问题就是：性能不佳、高延迟、频繁崩溃。</p><p>造成内存泄漏的常见原因有：</p><ul><li><strong>过多的缓存</strong>。及时清理过多的缓存。</li><li><strong>滥用闭包</strong>。尽量避免使用大量的闭包。</li><li><strong>定时器或回调太多</strong>。与节点或数据相关联的计时器不再需要时，DOM 节点对象可以清除，整个回调函数也不再需要。可是，计时器回调函数仍然没有被回收（计时器停止才会被回收）。当不需要 setTimeout 或 setInterval 时，<strong>定时器没有被清除</strong>，定时器的糊掉函数以及其内部依赖的变量都不能被回收，<strong>会造成内存泄漏</strong>。解决方法：在定时器完成工作时，需要手动清除定时器。</li><li><strong>太多无效的 DOM 引用</strong>。DOM 删除了，但是节点的引用还在，导致 GC 无法实现对其所占内存的回收。解决方法：给删除的 DOM 节点引用设置为 null。</li><li><strong>滥用全局变量</strong>。全局变量是根据定义无法被垃圾回收机制进行收集的，因此需要特别注意临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，请确保将其指定为 null 或在完成后重新分配它。解决方法：使用严格模式。</li><li><strong>从外到内执行 appendChild</strong>。此时即使调用 removeChild 也无法进行释放内存。解决方法：从内到外 appendChild。</li><li><strong>反复重写同一个数据会造成内存大量占用</strong>，但是 IE 浏览器关闭后会被释放。</li><li><strong>注意程序逻辑</strong>，避免编写『死循环』之类的代码。</li><li><strong>DOM 对象和 JS 对象相互引用</strong>。</li></ul><blockquote><p>本文参考：</p><p><a href="https://juejin.cn/post/6981588276356317214#heading-4">「硬核 JS」你真的了解垃圾回收机制吗</a></p><p><a href="https://juejin.cn/post/7038593947995734030#heading-2">Javascript 的垃圾回收机制知多少？</a></p></blockquote>]]></content>
    
    
    <summary type="html">JavaScript的垃圾回收机制</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="垃圾回收" scheme="https://munanchun.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>前端中的安全问题</title>
    <link href="https://munanchun.github.io/posts/9f4f1167.html"/>
    <id>https://munanchun.github.io/posts/9f4f1167.html</id>
    <published>2024-04-01T16:00:00.000Z</published>
    <updated>2024-04-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="几类和前端息息相关的安全问题"><a href="#几类和前端息息相关的安全问题" class="headerlink" title="几类和前端息息相关的安全问题"></a>几类和前端息息相关的安全问题</h2><p>前端开发者在开发过程中可能会遇到许多安全问题，主要包括以下几类：</p><ol><li><strong>网络协议攻击</strong>：这块主要包括 HTTP，HTTPS（证书过期，中间人劫持），DNS 劫持等问题</li><li><strong>跨站脚本攻击（XSS）</strong>：这是最常见的前端安全问题之一。攻击者通过注入恶意的 JavaScript 脚本，企图破坏网站的功能或者窃取用户的数据。</li><li><strong>跨站请求伪造（CSRF）</strong>：在这种攻击中，攻击者诱使用户去请求一个他们并不期望的网站，以此来执行一些恶意的操作。</li><li><strong>点击劫持</strong>：攻击者通过透明的元素或者弹窗，诱使用户在不知情的情况下点击一些链接或者按钮，以此来执行一些恶意的操作。</li><li><strong>混合内容问题</strong>：如果一个使用 HTTPS 协议的网站中，包含了使用 HTTP 协议的资源（如图片、脚本等），可能会导致用户的数据被窃取。这是因为 HTTP 协议的数据传输不是加密的，攻击者可以通过监听网络传输，来窃取这些数据。</li><li><strong>第三方库的安全问题</strong>：许多前端开发者在开发过程中，会使用一些第三方的库或者框架。如果这些库或者框架存在安全问题，或者被恶意修改，可能会引入一些安全风险。</li><li><strong>不安全的数据存储</strong>：在前端开发中，有时需要在用户的浏览器中存储一些数据。如果这些数据包含敏感信息，如密码、Token 等，并且存储方式不安全（如直接保存在 localStorage 等），可能会被攻击者窃取。</li></ol><hr><p>接下来我们分别介绍这几类的攻防策略</p><h3 id="网络协议攻击"><a href="#网络协议攻击" class="headerlink" title="网络协议攻击"></a>网络协议攻击</h3><p><strong>HTTP</strong></p><p>HTTP 是一种无状态的明文协议，数据在传输过程中并不加密，容易被中间人攻击。攻击者可以轻易地监听、捕获和篡改传输中的数据，包括敏感信息如用户名、密码、session ID 等。信道安全是最大问题</p><p><strong>HTTPS</strong></p><p>HTTPS 是基于 SSL/TLS 的 HTTP 加密版本，提供了数据的机密性、完整性和身份认证。然而，如果实施不当，HTTPS 也可能有安全隐患。例如，如果服务器的 SSL/TLS 版本过旧或配置不当，可能会遭受“中间人攻击”。此外，如果网站的 HTTPS 证书不合法或过期，也可能导致安全问题。</p><p><strong>中间人攻击</strong></p><p><code>中间人攻击（Man-in-the-Middle Attack，简称 MITM）</code>是一种网络攻击手段，攻击者插入到通信的两端之间，截取和可能篡改他们的通信。</p><p>在这种攻击中，攻击者让通信的双方认为他们正在直接和对方通信，但实际上，所有的通信都通过了攻击者。这样，攻击者就可以监听和捕获所有传输的信息，包括敏感信息，如登录凭证、信用卡号等。如果攻击者愿意，他们甚至可以更改通信的内容。</p><p>以下是几种常见的中间人攻击：</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">ARP Spoofing</button></li><li class="tab"><button type="button" data-href="#test-2">DNS Spoofing</button></li><li class="tab"><button type="button" data-href="#test-3">HTTPS Spoofing</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><strong>攻击者发送伪造的 ARP 消息到局域网，欺骗其他设备，让它们将网络数据发送到攻击者控制的设备上，而不是正确的目标设备。通过这种方式，攻击者可以拦截、窃取甚至篡改被传输的数据，以获取敏感信息或进行其他恶意活动。</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p><strong>攻击者通过篡改 DNS 查询的响应，将用户导向错误的 IP 地址。攻击者可以劫持 DNS 查询并发送虚假的响应，将用户引导到恶意站点，这可能是一个伪装的登录页面、钓鱼站点或包含恶意软件的网站。这种攻击可能导致用户受到欺骗、信息泄露或恶意软件感染。DNS Spoofing 通常发生在未经加密的网络上，例如公共 WiFi 网络，因为攻击者能够在这些网络上拦截和篡改通信。</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p><strong>攻击者创建一个伪造的 HTTPS 网站，将用户的流量引导到这个网站，从而窃取用户的信息。在 HTTPS 通信中，数据被加密以确保传输的安全性和隐私性。攻击者可能使用欺骗性手段，如仿冒合法网站、通过钓鱼邮件或欺诈性广告等方式，诱使用户访问这个伪造的 HTTPS 网站。一旦用户访问了这个伪造网站，攻击者就能够窃取用户的敏感信息，例如登录凭据、个人信息、支付信息等。HTTPS Spoofing 攻击是一种严重的安全威胁，因为用户通常会认为 HTTPS 连接是安全的，从而信任访问的网站。因此，防范此类攻击需要用户提高警惕，确保访问的网站是可信的，并且使用安全的网络连接。</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>为了防止中间人攻击，可以使用以下几种方法：</p><ul><li>使用加密的连接，如 HTTPS、VPN。这可以确保数据在传输过程中的安全，即使被攻击者截获也无法直接读取。</li><li>检查 SSL 证书。如果浏览器提示 SSL 证书有问题，那可能是正在遭受中间人攻击。不要忽视这些警告。</li><li>使用安全的 DNS 解析，如 DNSSEC，防止 DNS Spoofing。</li><li>使用网络安全工具，如防火墙，IDS 等，监控异常的网络行为。</li></ul><p><strong>DNS 劫持</strong></p><p>DNS 劫持是一种网络攻击方式。攻击者通过篡改 DNS（Domain Name System）查询的响应，将用户的域名解析请求指向错误的 IP 地址，通常是攻击者控制的恶意网站或服务器。这样一来，用户访问的网站实际上是攻击者控制的网站，可能导致用户的个人信息泄露、账户被盗、恶意软件感染等安全问题。</p><p>DNS 劫持攻击是一种比较隐蔽且危害较大的攻击方式，因为它直接影响了用户对网络资源的访问。<code>DNSSEC</code>（DNS Security Extensions）是一种用于加强 DNS 安全性的协议，它能够提供数据的完整性和认证性，有效防止 DNS 记录被篡改或 DNS 劫持攻击。然而，并非所有的网站和 ISP（Internet Service Provider，互联网服务提供商）都启用了<code>DNSSEC</code>，这导致 DNS 劫持仍然是一个存在的安全威胁。</p><hr><h3 id="XSS-安全"><a href="#XSS-安全" class="headerlink" title="XSS 安全"></a>XSS 安全</h3><p><strong>概念</strong></p><p><code>XSS（跨站脚本攻击）</code>是一种常见的网络攻击手段。在这种攻击中，攻击者通过注入恶意的 JavaScript 脚本来攻击网站的用户</p><p><strong>攻击</strong></p><p>XSS 攻击主要有以下几种类型：</p><ul><li><strong>存储型 XSS 攻击</strong>：攻击者将恶意的 JavaScript 脚本存储在网站的服务器上（例如，在一个评论区中发布含有恶意脚本的评论）。当其他用户浏览到包含这些脚本的页面时，就会执行这些脚本。</li><li><strong>反射型 XSS 攻击</strong>：在这种攻击中，攻击者会将恶意脚本包含在 URL 中。当用户点击这个 URL 时，恶意脚本会被网站的页面反射（即，直接在页面中输出），然后在用户的浏览器中执行。</li><li><strong>DOM 型 XSS 攻击</strong>：这种攻击是通过修改页面的 DOM 结构，使得恶意脚本得以执行。</li></ul><p><strong>防御</strong></p><p>对抗 XSS 攻击的防御方法有多种，以下是一些常见的方法：</p><ul><li><strong>数据输出时进行转义</strong>：对所有的用户输入进行 HTML 转义，可以有效防止 XSS 攻击。例如，将 <code>&lt;</code> 转义为 <code>&amp;lt</code>，将 <code>&gt;</code> 转义为 <code>&amp;gt</code>等。这样做的目的是防止浏览器将用户输入的数据误认为是 HTML 代码或者 JavaScript 脚本。</li><li><strong>使用内容安全策略（CSP）</strong>：内容安全策略是一种通过设置 HTTP 头部来告知浏览器哪些资源可以加载的安全机制。通过配置 CSP，可以限制页面加载外部资源的来源，包括脚本、样式表、图片等。这样即使 XSS 攻击者成功注入恶意脚本，浏览器也会拒绝执行来自非法来源的脚本，从而有效地减轻 XSS 攻击的危害。</li><li><strong>使用 HTTP-only cookies</strong>：将 cookies 设置为 HTTP-only 可以防止 JavaScript 通过 <code>document.cookie</code> API 读取这些 cookies。这样，即使攻击者注入了恶意脚本，也无法窃取用户的 cookies。</li><li><strong>使用最新的 JavaScript 框架</strong>：许多现代的 JavaScript 框架（如 React、Vue.js 等）内置了 XSS 防御机制。</li></ul><p><strong>前端框架集成等防范措施</strong></p><p>现代 JavaScript 框架。如 React、Vue.js 等，都有一些内置的防御机制，来帮助开发者避免 XSS 攻击。下面是一些具体的防御机制：</p><ol><li><strong>默认的数据绑定是安全的</strong>：在这些框架中，数据绑定到视图的方式通常是安全的。例如，在 Vue 和 React 中，使用双大括号 <code>&#123;&#123; &#125;&#125;</code> 或 JSX 的 <code>&#123;&#125;</code> 来插入数据时，框架会自动对其进行转义，以防止数据被解析为 HTML 或 JavaScript。这样，即使数据中包含有潜在的 XSS 攻击代码，也不会被执行。</li><li><strong>提供安全的编码函数</strong>：当需要在视图中插入未转义的 HTML 时，这些框架通常会提供安全的方法。例如，React 的 <code>dangerouslySetInnerHTML</code>，Vue 的 <code>v-html</code> 指令。虽然这些方法允许插入未转义的 HTML，但它们的名称都强调了这种操作的危险性，提醒开发者需要谨慎使用。</li><li><strong>Content Security Policy (CSP) 支持</strong>：许多现代框架也支持内容安全策略 (CSP)，这是一种防止 XSS 攻击的安全措施。CSP 可以限制网页中能执行的脚本的来源，有效地阻止 XSS 攻击。</li></ol><p>虽然这些框架提供了一些内置的防御机制，但仍然需要开发者了解 XSS 攻击的原理，并在编写代码时遵循一些最佳实践，如对用户输入进行校验，使用 HTTP-only cookies 等，才能更有效地防止 XSS 攻击。</p><hr><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p><strong>攻击</strong></p><p><code>CSRF（跨站请求伪造）</code>是一种网络攻击手段，主要是攻击者利用用户已登录的身份，伪造用户去请求服务器。这种攻击方式可以诱导用户执行攻击者预设的操作，如修改密码、购买商品等。</p><p>假设一个场景：用户在一家银行的网站上登录了自己的账户。如果该网站存在 CSRF 漏洞，攻击者可以设置一个陷阱，比如在论坛中发帖附带一个链接，这个链接是银行网站的一个转账接口，而且指定了收款人和转账金额。如果用户点击了这个链接，那么银行网站可能会认为是用户自己发起的转账请求，从而进行转账。<br>这种攻击方法的关键在于，用户并不知道自己发起了这个请求，而服务器也无法分辨这个请求是不是用户本人意愿发起的，这就给攻击者留下了可乘之机。</p><p>CSRF 攻击有一定的局限性，它必须基于用户已经登录了目标网站，并且该网站有 CSRF 漏洞存在。此外，攻击者也不能预知 CSRF 攻击的具体结果，因为这取决于被攻击的网站的业务逻辑。</p><p><strong>防御</strong></p><p>为了防御 CSRF 攻击，我们可以使用一些方法，例如使用 CSRF token，验证 HTTP Referer 字段，或者使用 SameSite Cookie 等。</p><p>一种常见的 CSRF 防御机制是使用 CSRF token。</p><p>以下是一个简单的 JavaScript 的 CSRF token 生成和验证的例子。</p><p>首先，我们需要一个函数来生成 CSRF token：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generateCSRFToken</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这里只是一个简单的实现，实际使用时可能需要更复杂的方式生成token</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际应用中，服务器在响应客户端的请求时，会生成一个 CSRF token，并在响应中将其发送给客户端。客户端在发送请求时，会将这个 token 作为一部分请求数据发送给服务器。</p><p>服务器在收到请求时，会验证请求中的 token 是否和服务器发送的 token 一致。以下是一个简单的验证函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">verifyCSRFToken</span>(<span class="params">serverToken, clientToken</span>) &#123;</span><br><span class="line">  <span class="comment">// 比较两个token是否一致</span></span><br><span class="line">  <span class="keyword">return</span> serverToken === clientToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是在现代前端框架中 CSRF 的开启往往也是个 config 选项透出</p><hr><h3 id="点击劫持问题（Clickjacking）"><a href="#点击劫持问题（Clickjacking）" class="headerlink" title="点击劫持问题（Clickjacking）"></a>点击劫持问题（Clickjacking）</h3><p><strong>概念</strong></p><p><code>点击劫持（Clickjacking）</code>是一种常见的网络攻击手段，也被称为“UI 覆盖攻击”。在这种攻击中，攻击者将一个透明的、恶意的网页覆盖在一个用户期望看到的网页上面。当用户在页面上进行操作（如点击按钮）时，他们实际上是在点击攻击者的透明页面，从而触发了攻击者预设的行为。这个行为在实际业务开发中会被忽视，但是基建团队一般也都会在构建 config 里给我们配置上类似 <code>X-Frame-Options</code> 和<code>csp</code> 的选项为了防止这些问题。</p><p><strong>防御策略</strong></p><ul><li><p>使用 <code>X-Frame-Options HTTP</code> 响应头：这是一种 HTTP 响应头，可以防止你的网页被嵌入到其他网页的 iframe 中。你可以将这个响应头设置为 DENY（禁止所有的域嵌入你的网页），或者 <code>SAMEORIGIN</code>（只允许相同域名的网页嵌入你的网页）。</p></li><li><p>使用 Content Security Policy (CSP)：CSP 是一种控制网页内容的安全策略，你可以使用 <code>frame-ancestors</code> 指令，来限制哪些网页可以嵌入你的网页。</p></li><li><p>使用 JavaScript 检测：你可以在你的网页中添加 JavaScript 代码，检测你的网页是否被嵌入到 iframe 中。如果是，那么可以让网页跳出 iframe，显示在顶层窗口。</p></li></ul><p>需要注意的是，虽然上述方法可以有效防止点击劫持，但没有任何一种方法是绝对安全的。因此，作为开发者，我们应该尽量使用多种防御策略，以增加攻击者的攻击成本。</p><p><strong>基本防御 case</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (top !== self) &#123;</span><br><span class="line">  top.<span class="property">location</span> = self.<span class="property">location</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是，如果当前页面不是顶层窗口（被嵌入到了其他页面的 iframe 中），那么就将顶层窗口的地址设置为当前页面的地址，使得当前页面显示在顶层窗口，从而跳出 iframe。</p><hr><h3 id="混合内容问题"><a href="#混合内容问题" class="headerlink" title="混合内容问题"></a><strong>混合内容问题</strong></h3><p>混合内容问题指的是一个使用 HTTPS 协议的网页，包含了使用 HTTP 协议的资源。由于 HTTP 是明文传输，这种情况下，即使主页面是 HTTPS，但包含的 HTTP 资源在传输过程中仍可能被窃取或篡改，从而导致用户的信息泄露或被欺骗。特别是在使用框架页面时，可能需要引入其他来源的内容，容易出现混合内容问题。因此，我们应该时刻注意网站是否存在混合内容问题，并及时进行修复。</p><p><strong>防御</strong></p><ol><li><strong>使用 HTTPS 来加载所有资源</strong>：这是最直接、最有效的解决方法。无论是图片、脚本、样式表，还是其他任何类型的资源，都应该使用 HTTPS 来加载。</li><li><strong>使用相对 URL</strong>：如果你的网站同时支持 HTTP 和 HTTPS，那么可以使用相对 URL 来引用资源，如 <code>&quot;/path/to/my/script.js&quot;</code>，而不是 <code>&quot;http://example.com/path/to/my/script.js&quot;</code>。这样，浏览器会使用和主页面相同的协议来加载资源。</li><li><strong>使用 Content Security Policy (CSP)</strong>：CSP 是一种用来控制网页可以加载哪些资源的安全策略。你可以设置 CSP 的 <code>upgrade-insecure-requests</code> 指令，来自动将所有的 HTTP 请求升级到 HTTPS。</li><li><strong>使用 HTTP Strict Transport Security (HSTS) 头</strong>：HSTS 是一种安全策略，它告诉浏览器，这个网站只能通过 HTTPS 访问。开启 HSTS 后，浏览器会自动将所有的 HTTP 请求升级到 HTTPS。</li></ol><hr><h3 id="第三方库的安全问题"><a href="#第三方库的安全问题" class="headerlink" title="第三方库的安全问题"></a><strong>第三方库的安全问题</strong></h3><p><strong>问题</strong></p><p>我想许多公司的业务代码架构治理都在解决这个问题。当我们一个迭代项目中依赖的包存在安全问题，或者这个包已经不推荐无人维护，或者这个包直接被恶意篡改（投毒），都会引入安全风险。</p><p><strong>防御</strong></p><p>在实际的业务治理过程中，架构师通常会制定精品库，由专门的团队负责维护并将其集成到团队的业务框架中，例如标准化的业务线库（如 stdlib）。同时，团队会提供代码扫描工具，通过持续集成等时机不断扫描项目，发现老旧库或不推荐使用的库并及时进行告警。这样可以及时发现和解决潜在的安全问题，提高项目的安全性和稳定性。</p><hr><h3 id="不安全的数据存储"><a href="#不安全的数据存储" class="headerlink" title="不安全的数据存储"></a>不安全的数据存储</h3><p><strong>问题</strong></p><p>在 web 开发中，不安全的数据存储可以引起许多安全问题。如果攻击者能够访问或者修改存储的数据，可能会泄露敏感信息，或者造成其他的安全问题。</p><p><strong>防御</strong></p><ol><li><strong>使用安全的 cookie 设置</strong>：对于存储在 cookie 中的数据，应该使用 <code>Secure</code> 和 <code>HttpOnly</code> 标志来保护它们。Secure 标志可以确保 cookie 只通过 HTTPS 发送，HttpOnly 标志可以防止 JavaScript 访问 cookie。</li><li><strong>敏感信息加密存储</strong>：对于敏感信息，如密码，应该进行哈希和加盐存储，而不是明文存储。哈希可以确保即使数据库被泄露，攻击者也无法直接获取到原始的密码。加盐可以进一步增加破解的难度。</li><li><strong>避免在 localStorage 中存储敏感信息</strong>：localStorage 是持久性的，并且在同源的所有页面中都可访问。因此，如果你在 localStorage 中存储敏感信息，可能会有被 XSS 攻击窃取的风险。你应该避免在 localStorage 中存储敏感信息，或者至少对它们进行加密。</li><li><strong>限制并监控数据的访问</strong>：应该限制谁可以访问存储的数据以及他们可以进行的操作。对于敏感操作，如数据的修改和删除，应该进行记录和监控。</li></ol><p>安全的数据存储需要多方面的考虑和措施，包括<strong>传输的安全</strong>，<strong>存储的安全</strong>，以及<strong>访问的安全</strong>。</p><blockquote><p>本文参考：</p><p><a href="https://zhuanlan.zhihu.com/p/633783486#:~:text=%E5%87%A0%E7%B1%BB%E5%92%8C%E5%89%8D%E7%AB%AF%E6%81%AF%E6%81%AF%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%201%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%94%BB%E5%87%BB%EF%BC%9A%20%E8%BF%99%E5%9D%97%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%20HTTP%EF%BC%8CHTTPS%EF%BC%88%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%EF%BC%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E5%8A%AB%E6%8C%81%EF%BC%89%EF%BC%8CDNS%E5%8A%AB%E6%8C%81%E7%AD%89%E9%97%AE%E9%A2%98%202%20%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%88XSS%EF%BC%89%20%EF%BC%9A%E8%BF%99%E6%98%AF%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%B9%8B%E4%B8%80%E3%80%82,6%20%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%20%EF%BC%9A%E8%AE%B8%E5%A4%9A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%9C%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E4%BA%9B%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E5%BA%93%E6%88%96%E8%80%85%E6%A1%86%E6%9E%B6%E3%80%82%20...%207%20%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20%EF%BC%9A%E5%9C%A8%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E6%9C%89%E6%97%B6%E9%9C%80%E8%A6%81%E5%9C%A8%E7%94%A8%E6%88%B7%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%AD%98%E5%82%A8%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E3%80%82%20">聊聊前端中的安全问题</a></p></blockquote>]]></content>
    
    
    <summary type="html">几类和前端息息相关的安全问题</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="安全" scheme="https://munanchun.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端实现token无感刷新</title>
    <link href="https://munanchun.github.io/posts/9a8537ce.html"/>
    <id>https://munanchun.github.io/posts/9a8537ce.html</id>
    <published>2024-03-22T16:00:00.000Z</published>
    <updated>2024-03-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现无感刷新-Token-的前端解决方案"><a href="#实现无感刷新-Token-的前端解决方案" class="headerlink" title="实现无感刷新 Token 的前端解决方案"></a>实现无感刷新 Token 的前端解决方案</h2><p>在前端开发中，处理用户登录状态下 Token 过期的问题至关重要。</p><h3 id="1-问题现象及原因"><a href="#1-问题现象及原因" class="headerlink" title="1. 问题现象及原因"></a>1. 问题现象及原因</h3><p>当用户登录状态下 Token 过期时，可能会出现突然跳转到登录页面的情况。这是因为前端请求拦截器检测到 Token 过期，导致请求失败，服务器返回状态码 401，触发前端跳转到登录页面的逻辑。</p><h3 id="2-解决方案概述"><a href="#2-解决方案概述" class="headerlink" title="2. 解决方案概述"></a>2. 解决方案概述</h3><p>通过双 Token 机制（access_token 和 refresh_token）实现无感刷新 Token。具体流程包括：</p><ul><li>拦截请求：在请求中携带 access_token 进行鉴权，后端验证 Token 的有效性。</li><li>响应拦截：捕获请求失败，判断是否为 Token 过期导致的失败，若是则调用刷新 Token 的接口。</li><li>刷新 Token：利用 refresh_token 获取新的 access_token，更新本地存储的 Token。</li><li>重新发送请求：在 Token 刷新成功后，重新发送之前因 Token 过期而失败的请求，确保用户操作的连贯性。</li></ul><div class="note info simple"><p>注：如果 refresh_token 也过期了，那么则需要清除掉所有 token（access_token 和 refresh_token），返回登录页登录。在刷新 access_token 的同时，最好也能刷新 refresh_token，比如 refresh_token 设置过期为 7 天，刷新一次 access_token 后把 refresh_token 又往后续了 7 天。这也是为什么很多软件登录后几乎不用再登录的原因。</p></div><div class="note warning simple"><p>提示：在刷新 access_token 的时候，建议设置一个标识变量用于标识 access_token 是否已经刷新了，毕竟过期时发起的请求可能有多条，响应拦截后没必要重复刷新 access_token，而且重复刷新 acces_token 可能会报错，因为最先执行完的刷新请求已经将 refresh_token 更新了，而后面执行的刷新请求还是使用旧的 refresh_token</p></div><h3 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3. 具体实现"></a>3. 具体实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axiosInstance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;XXX&quot;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span>, <span class="comment">// 请求超时时间</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">HOME_PAGE</span> = <span class="string">&quot;/&quot;</span>; <span class="comment">// 登录页面的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装 refreshToken 逻辑</span></span><br><span class="line"><span class="keyword">let</span> expiredRequestArr = []; <span class="comment">// 存储失败的请求</span></span><br><span class="line"><span class="keyword">let</span> firstRequest = <span class="literal">true</span>; <span class="comment">// 控制是否首次刷新 Token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储当前因为 Token 失效导致发送失败的请求</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">saveErrorRequest</span> = (<span class="params">expiredRequest</span>) =&gt; &#123;</span><br><span class="line">  expiredRequestArr.<span class="title function_">push</span>(expiredRequest);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 refreshToken 更新当前使用的 Token</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">updateTokenByRefreshToken</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  axiosInstance</span><br><span class="line">    .<span class="title function_">post</span>(<span class="string">&quot;/refreshToken&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; accessToken &#125; = res.<span class="property">data</span>;</span><br><span class="line">      <span class="comment">// 更新本地 Token</span></span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;accessToken&quot;</span>, accessToken);</span><br><span class="line">      <span class="comment">// 重新发送失败的请求</span></span><br><span class="line">      expiredRequestArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">request</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">request</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">      expiredRequestArr = [];</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;刷新 Token 失败&quot;</span>, err);</span><br><span class="line">      <span class="comment">// 刷新 Token 失败跳转登录页</span></span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">`<span class="subst">$&#123;HOME_PAGE&#125;</span>/login`</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// refreshToken 函数，尝试刷新 Token</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">refreshToken</span> = (<span class="params">expiredRequest</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">saveErrorRequest</span>(expiredRequest);</span><br><span class="line">  <span class="keyword">if</span> (firstRequest) &#123;</span><br><span class="line">    <span class="title function_">updateTokenByRefreshToken</span>(); <span class="comment">// 刷新 Token</span></span><br><span class="line">    firstRequest = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器处理 Token 过期</span></span><br><span class="line">axiosInstance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存失败的请求并尝试刷新 Token</span></span><br><span class="line">      <span class="title function_">saveErrorRequest</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">axiosInstance</span>(error.<span class="property">config</span>); <span class="comment">// 刷新 Token 后重新发送请求</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (firstRequest) &#123;</span><br><span class="line">        <span class="title function_">updateTokenByRefreshToken</span>(); <span class="comment">// 刷新 Token</span></span><br><span class="line">        firstRequest = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error.<span class="property">response</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="4-实操流程"><a href="#4-实操流程" class="headerlink" title="4. 实操流程"></a>4. 实操流程</h3><ol><li>登录成功后，获取 access_token 和 refresh_token。</li><li>请求接口时，在请求头中携带 access_token 进行鉴权。</li><li>当请求失败且状态码为 401 时，调用刷新 Token 的接口。</li><li>刷新 Token 成功后，重新发送之前失败的请求。</li></ol><p>通过以上实现，用户可以在不受 Token 过期影响的情况下，持续地使用应用，提升了用户体验。</p>]]></content>
    
    
    <summary type="html">实现无感刷新 Token 的前端解决方案</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="axios" scheme="https://munanchun.github.io/tags/axios/"/>
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="无感刷新" scheme="https://munanchun.github.io/tags/%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染进程的多线程机制与单线程处理的优缺点</title>
    <link href="https://munanchun.github.io/posts/648fc82d.html"/>
    <id>https://munanchun.github.io/posts/648fc82d.html</id>
    <published>2024-03-20T16:00:00.000Z</published>
    <updated>2024-03-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，了解浏览器渲染进程的多线程机制以及单线程处理的优缺点至关重要。</p><h2 id="浏览器渲染进程的多线程机制"><a href="#浏览器渲染进程的多线程机制" class="headerlink" title="浏览器渲染进程的多线程机制"></a>浏览器渲染进程的多线程机制</h2><p>在浏览器中，渲染进程是负责处理页面渲染、JavaScript 执行和事件循环等任务的核心进程。这个渲染进程是多线程的，主要包括以下几个线程：</p><ol><li><p><strong>GUI 渲染线程：</strong> 负责渲染浏览器界面，解析 HTML、CSS，并构建 <code>DOM</code> 树和 <code>RenderObject</code> 树等。当界面需要重绘或回流时，该线程就会执行。</p><blockquote><p><strong>需要注意的是</strong>：<strong>GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</strong>。</p></blockquote></li><li><p><strong>JS 引擎线程：</strong> 负责处理 JavaScript 脚本程序，如解析和执行 JavaScript 代码。在一个 Tab 页中，始终只有一个 JS 线程在运行 JavaScript 程序。</p><blockquote><p><strong>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</strong>。</p></blockquote></li><li><p><strong>事件触发线程：</strong> 用于控制事件循环，处理诸如鼠标点击、键盘输入等事件。当事件被触发时，该线程会将事件添加到待处理队列中，等待 JS 引擎处理。</p><blockquote><p><strong>由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</strong></p></blockquote></li><li><p><strong>定时触发器线程：</strong> 负责管理定时器，例如 <code>setInterval</code> 和 <code>setTimeout</code>。这个线程会计时，并在计时完成后将任务添加到事件队列中，等待 JS 引擎处理。</p></li><li><p><strong>异步 HTTP 请求线程：</strong> 负责处理异步的网络请求，如 <code>XMLHttpRequest</code>。当请求完成时，会将回调函数添加到事件队列中，等待 JS 引擎处理。</p></li></ol><h2 id="为什么渲染进程通常采用单线程处理"><a href="#为什么渲染进程通常采用单线程处理" class="headerlink" title="为什么渲染进程通常采用单线程处理"></a>为什么渲染进程通常采用单线程处理</h2><p>尽管浏览器渲染进程是多线程的，但通常采用单线程处理的方式，这是因为多线程处理可能会引发多种问题：</p><ol><li><strong>竞态条件：</strong> 多线程处理可能会导致访问共享内存的竞态条件，造成数据不一致和死锁等问题。</li><li><strong>同步问题：</strong> 多线程需要进行同步，避免数据竞争和死锁，增加了代码的复杂度和开销。</li><li><strong>安全问题：</strong> 多线程可能会存在安全漏洞，如数据泄露、内存溢出等问题。</li><li><strong>性能问题：</strong> 多线程处理可能会导致过多的上下文切换和内存消耗，降低了程序的性能和稳定性。</li></ol><p>相比之下，单线程处理具有以下优点：</p><ul><li><strong>简单易用：</strong> 单线程处理方式更加简单易用，不需要考虑多线程处理中的竞态条件和同步问题。</li><li><strong>可靠稳定：</strong> 单线程处理避免了多线程处理中的死锁和资源争用等问题，提高了程序的可靠性和稳定性。</li><li><strong>高效节省：</strong> 单线程处理可以避免多线程处理中的上下文切换和内存消耗等问题，提高了程序的性能和节省了系统资源。</li></ul><p>尽管单线程处理可能会存在一些缺点，如无法充分利用多核 CPU，但通过事件循环和异步编程等技术，可以提高程序的性能和并发处理能力，从而克服单线程的局限性。</p>]]></content>
    
    
    <summary type="html">浏览器渲染进程的多线程机制与单线程处理的优缺点</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://munanchun.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>移动端1px问题</title>
    <link href="https://munanchun.github.io/posts/6cebc21a.html"/>
    <id>https://munanchun.github.io/posts/6cebc21a.html</id>
    <published>2024-03-17T16:00:00.000Z</published>
    <updated>2024-03-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么会有1px的问题"><a href="#为什么会有1px的问题" class="headerlink" title="为什么会有1px的问题"></a>为什么会有<code>1px</code>的问题</h2><p>在开发移动端项目时，针对屏幕分辨率为 <code>375*667</code> 的设备，UI 设计师给的设计稿是 <code>750*1334</code> 像素的，对于 UI 来说，这 <code>1px</code> 是相对于 <code>750*1334</code>，而我们写的 <code>1px</code> 的 css 是相对于 <code>375*667</code> 的，所以映射到 <code>750*1334</code> 的设计稿就是 <code>2px</code></p><p>此时我们会发出两个问题：</p><ol><li>为什么 UI 针对 <code>375*667</code> 的设备设计 <code>750*1334</code> 的图</li><li>为什么不写 <code>0.5px</code></li></ol><h2 id="为什么要设计-750-1334-的图"><a href="#为什么要设计-750-1334-的图" class="headerlink" title="为什么要设计 750*1334 的图"></a>为什么要设计 <code>750*1334</code> 的图</h2><p>先看一张图：</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/54.webp' /></div><p><strong>关于设备像素、css 像素、设备独立像素与 dpr 之间的区别，请参考站长文章：</strong></p><p><a href="https://wjldarling.top/posts/73b02dc6">浅谈设备像素、css 像素、设备独立像素、dpr 之间的区别</a></p><h2 id="为什么不写-0-5px"><a href="#为什么不写-0-5px" class="headerlink" title="为什么不写 0.5px"></a>为什么不写 0.5px</h2><p>其中 Chrome 把 0.5px 四舍五入变成了 1px，而 firefox/safari 能够画出半个像素的边，并且 Chrome 会把小于 0.5px 的当成 0，而 Firefox 会把不小于 0.55px 当成 1px，Safari 是把不小于 0.75px 当成 1px，进一步在手机上观察 iOS 的 Chrome 会画出 0.5px 的边，而安卓(5.0)原生浏览器是不行的。所以直接设置 0.5px 不同浏览器的差异比较大，并且我们看到不同系统的不同浏览器对小数点的 px 有不同的处理。所以如果我们把单位设置成小数的 px 包括宽高等，其实不太可靠，因为不同浏览器表现不一样。如下图所示：</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/56.webp' /></div><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1、小数值-px"><a href="#1、小数值-px" class="headerlink" title="1、小数值 px"></a>1、小数值 px</h3><p>解决思路</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000000;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">devicePixelRatio</span> &amp;&amp; devicePixelRatio &gt;= <span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> main = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;main&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    main.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&quot;.5px solid #000000&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong>：简单，好理解</p><p><strong>缺点</strong>：容性差，目前之余 IOS8+才支持，在 IOS7 及其以下、安卓系统都是显示 0px。</p><h3 id="2、通过图片模拟实现-1px"><a href="#2、通过图片模拟实现-1px" class="headerlink" title="2、通过图片模拟实现 1px"></a>2、通过图片模拟实现 1px</h3><p><strong>实现原理：</strong> 因为 <code>1px</code> 会被渲染为 <code>2px</code>，故我们可以设计一个 <code>2*2px</code> 的图，如果需要设置上边框，则把下面 <code>1px</code> 设置为透明，将上面 <code>1px</code> 设置为我们需要的颜色即可，如下图所示</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/57.webp' /></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="selector-class">.border</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">border.png</span>) <span class="number">2</span> repeat;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：图片可以用<code>gif</code>, <code>png</code>, <code>base64</code>多种格式, 以上是上下左右四条边框的写法, 需要单一边框只要定义单一边框的 border, 代码比较直观</p><p><strong>缺点</strong>：更换颜色需要更换图片，圆角模糊</p><h3 id="3、background-img-渐变"><a href="#3、background-img-渐变" class="headerlink" title="3、background-img 渐变"></a>3、background-img 渐变</h3><p><strong>实现原理：</strong> 将元素设置为 <code>1px</code>，再通过背景图片渐变裁剪实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">css复制代码<span class="selector-class">.linear-gradient</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.linear-gradient</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="comment">/* background: linear-gradient(180deg, #999, #999 50%, transparent 50%); */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">180deg</span>, transparent, transparent <span class="number">50%</span>, <span class="number">#999</span> <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：实现简单，无副作用</p><p><strong>缺点</strong>：不能设置四边，无法设置圆角</p><h3 id="4、CSS3-box-shadow"><a href="#4、CSS3-box-shadow" class="headerlink" title="4、CSS3 box-shadow"></a>4、CSS3 box-shadow</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">css复制代码<span class="selector-class">.shadow</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> -<span class="number">1px</span> <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> -<span class="number">1px</span> <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟效果：没觉得这个方法好用，模拟的效果差强人意，颜色也不好配置，不推荐</p><h3 id="5、使用-viewport-initial-scale"><a href="#5、使用-viewport-initial-scale" class="headerlink" title="5、使用 viewport initial-scale"></a>5、使用 viewport initial-scale</h3><p><strong>实现原理：</strong> 设置整个页面进行缩小，并设置用户不能对页面进行缩放，然后写 <code>1px</code> 页面即可展示 <code>1px</code> 的边框，在<code>devicePixelRatio=2</code>设置 meta</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-eidth, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong>：可以直接写 <code>1px</code>，兼容性好，适合搭配新项目使用</p><p><strong>缺点</strong>：会让页面缩小，如果是老项目，需要全部的更改 css 样式</p><h3 id="6、-before-after和transform"><a href="#6、-before-after和transform" class="headerlink" title="6、:before:after和transform"></a>6、<code>:before:after</code>和<code>transform</code></h3><p>原理是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位。</p><p>单条 border 样式设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale-1px</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四条 border 样式设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale-1px</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  -webkit-<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: left top;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合 js 来代码来判断是否是 Retina 屏</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">devicePixelRatio</span> &amp;&amp; devicePixelRatio &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>).<span class="property">className</span> = <span class="string">&quot;scale-1px&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li>所有场景都能满足</li><li>支持圆角</li></ul><p><strong>缺点</strong>：</p><ul><li>对于已经使用伪类的元素，可能需要多层嵌套</li></ul><h3 id="7、通过-svg-实现"><a href="#7、通过-svg-实现" class="headerlink" title="7、通过 svg 实现"></a>7、通过 svg 实现</h3><p><strong>实现原理：</strong> 因为 <code>svg</code> 是矢量图形，它的 <code>1px</code> 对应的物理像素就是 <code>1px</code></p><p>可以搭配 <code>PostCSS</code> 的 <code>postcss-write-svg</code> 使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@svg</span> border_1px &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="keyword">@rect</span> &#123;</span><br><span class="line">    fill: <span class="built_in">var</span>(--color, black);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.svg</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-image</span>: <span class="built_in">svg</span>(border_1px <span class="built_in">param</span>(--color <span class="number">#00b1ff</span>)) <span class="number">2</span> <span class="number">2</span> stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.svg</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; height=&#x27;2px&#x27;%3E%3Crect fill=&#x27;%2300b1ff&#x27; width=&#x27;100%25&#x27; height=&#x27;50%25&#x27;/%3E%3C/svg%3E&quot;</span>)</span><br><span class="line">    <span class="number">2</span> <span class="number">2</span> stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：实现简单，可以实现圆角，</p><p><strong>缺点</strong>：需要学习 <code>svg</code> 语法</p><h2 id="开源库的解决方案"><a href="#开源库的解决方案" class="headerlink" title="开源库的解决方案"></a>开源库的解决方案</h2><p>一些开源库也有自己对于 1px 的解决方案</p><h3 id="vant"><a href="#vant" class="headerlink" title="vant"></a>vant</h3><p>使用<code>less</code>写的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hairline-common</span>() &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hairline</span>(<span class="variable">@color</span>: <span class="variable">@border-color</span>) &#123;</span><br><span class="line">  <span class="selector-class">.hairline-common</span>();</span><br><span class="line"></span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span> solid <span class="variable">@color</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ant-design-mobile"><a href="#ant-design-mobile" class="headerlink" title="ant-design-mobile"></a>ant-design-mobile</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale-hairline-common</span>(<span class="variable">@color</span>, <span class="variable">@top</span>, <span class="variable">@right</span>, <span class="variable">@bottom</span>, <span class="variable">@left</span>) &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">@color</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="variable">@top</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="variable">@right</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="variable">@bottom</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="variable">@left</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hairline</span>(<span class="variable">@direction</span>, <span class="variable">@color</span>: <span class="variable">@border-color-base</span>) <span class="keyword">when</span> (<span class="variable">@direction</span> = <span class="string">&quot;top&quot;</span>) &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="variable">@color</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">html</span><span class="selector-pseudo">:not</span>([data-scale]) <span class="selector-tag">&amp;</span> &#123;</span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-resolution</span>: <span class="number">2dppx</span>) &#123;</span><br><span class="line">      <span class="attribute">border-top</span>: none;</span><br><span class="line"></span><br><span class="line">      <span class="selector-tag">&amp;</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">        <span class="selector-class">.scale-hairline-common</span>(<span class="variable">@color</span>, <span class="number">0</span>, auto, auto, <span class="number">0</span>);</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@media</span> (<span class="attribute">min-resolution</span>: <span class="number">3dppx</span>) &#123;</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.33</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hairline</span>(<span class="variable">@direction</span>, <span class="variable">@color</span>: <span class="variable">@border-color-base</span>) <span class="keyword">when</span> (<span class="variable">@direction</span> = <span class="string">&quot;right&quot;</span>) &#123;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1px</span> solid <span class="variable">@color</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">html</span><span class="selector-pseudo">:not</span>([data-scale]) <span class="selector-tag">&amp;</span> &#123;</span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-resolution</span>: <span class="number">2dppx</span>) &#123;</span><br><span class="line">      <span class="attribute">border-right</span>: none;</span><br><span class="line"></span><br><span class="line">      <span class="selector-tag">&amp;</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        <span class="selector-class">.scale-hairline-common</span>(<span class="variable">@color</span>, <span class="number">0</span>, <span class="number">0</span>, auto, auto);</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="variable">@color</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">100%</span> <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@media</span> (<span class="attribute">min-resolution</span>: <span class="number">3dppx</span>) &#123;</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.33</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hairline</span>(<span class="variable">@direction</span>, <span class="variable">@color</span>: <span class="variable">@border-color-base</span>) <span class="keyword">when</span> (<span class="variable">@direction</span> = <span class="string">&quot;bottom&quot;</span>) &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="variable">@color</span>;</span><br><span class="line">  <span class="selector-tag">html</span><span class="selector-pseudo">:not</span>([data-scale]) <span class="selector-tag">&amp;</span> &#123;</span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-resolution</span>: <span class="number">2dppx</span>) &#123;</span><br><span class="line">      <span class="attribute">border-bottom</span>: none;</span><br><span class="line">      <span class="selector-tag">&amp;</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        <span class="selector-class">.scale-hairline-common</span>(<span class="variable">@color</span>, auto, auto, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">@media</span> (<span class="attribute">min-resolution</span>: <span class="number">3dppx</span>) &#123;</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.33</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hairline</span>(<span class="variable">@direction</span>, <span class="variable">@color</span>: <span class="variable">@border-color-base</span>) <span class="keyword">when</span> (<span class="variable">@direction</span> = <span class="string">&quot;left&quot;</span>) &#123;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="variable">@color</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">html</span><span class="selector-pseudo">:not</span>([data-scale]) <span class="selector-tag">&amp;</span> &#123;</span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-resolution</span>: <span class="number">2dppx</span>) &#123;</span><br><span class="line">      <span class="attribute">border-left</span>: none;</span><br><span class="line"></span><br><span class="line">      <span class="selector-tag">&amp;</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">        <span class="selector-class">.scale-hairline-common</span>(<span class="variable">@color</span>, <span class="number">0</span>, auto, auto, <span class="number">0</span>);</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">100%</span> <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@media</span> (<span class="attribute">min-resolution</span>: <span class="number">3dppx</span>) &#123;</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.33</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hairline</span>(<span class="variable">@direction</span>, <span class="variable">@color</span>: <span class="variable">@border-color-base</span>, <span class="variable">@radius</span>: <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">when</span></span><br><span class="line">  (<span class="variable">@direction</span> = <span class="string">&quot;all&quot;</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">@color</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="variable">@radius</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">html</span><span class="selector-pseudo">:not</span>([data-scale]) <span class="selector-tag">&amp;</span> &#123;</span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-resolution</span>: <span class="number">2dppx</span>) &#123;</span><br><span class="line">      <span class="attribute">position</span>: relative;</span><br><span class="line">      <span class="attribute">border</span>: none;</span><br><span class="line"></span><br><span class="line">      <span class="selector-tag">&amp;</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">@color</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="variable">@radius</span> * <span class="number">2</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">        <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">        <span class="attribute">pointer-events</span>: none;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @media (min-resolution: 3dppx) &#123;</span></span><br><span class="line">        <span class="comment">//   width: 300%;</span></span><br><span class="line">        <span class="comment">//   height: 300%;</span></span><br><span class="line">        <span class="comment">//   border-radius: @radius * 3;</span></span><br><span class="line">        <span class="comment">//   transform: scale(0.33);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个值得研究下，比 vant 和 第一种解决方案有点不同，主要在于处理了 DPR 为 2 和为 3 的两种情况，相比来说更加完善。</p><blockquote><p>这里 PX 大写，为了防止插件将 px 转成 rem 等单位</p></blockquote><hr><p><strong>最后，粘一份原生<code>hairline</code></strong></p><p>对应参考：<a href="https://wjldarling.top/posts/38e1ff4a">用 JavaScript 创建一个灵活且响应迅速的网页设计</a> （其中 46 行代码对应的<code>hairline</code>）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.demo</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.origin</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hairline</span>,</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hairline-top</span>,</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hairline-right</span>,</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hairline-bottom</span>,</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hairline-left</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hairline</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: -<span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>: -<span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: -<span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">bottom</span>: -<span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hairline-top</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-top</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hairline-right</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-right</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hairline-bottom</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hairline-left</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-left</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo origin&quot;</span>&gt;</span>normal 1px<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo hairline&quot;</span>&gt;</span>hairline<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo hairline-top&quot;</span>&gt;</span>top hairline<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo hairline-right&quot;</span>&gt;</span>right hairline<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo hairline-bottom&quot;</span>&gt;</span>bottom hairline<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo hairline-left&quot;</span>&gt;</span>left hairline<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多详情参考：</p><p><a href="https://github.com/amfe/article/issues/17">使用 Flexible 实现手淘 H5 页面的终端适配</a></p><blockquote><p>本文参考：</p><p><a href="https://zhuanlan.zhihu.com/p/268419107">吃透移动端 1px (hairline) - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/7034775285237022757#heading-13">移动端 1px 像素问题及解决办法 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6954011988380876831#heading-17">娓娓道来为什么移动端会有 1px 问题以及解决方案（附 demo） - 掘金 (juejin.cn)</a></p></blockquote>]]></content>
    
    
    <summary type="html">移动端1px像素问题以及解决方案</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="移动端" scheme="https://munanchun.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue3中使用webscoket（心跳、重连）</title>
    <link href="https://munanchun.github.io/posts/624eab8f.html"/>
    <id>https://munanchun.github.io/posts/624eab8f.html</id>
    <published>2024-03-04T16:00:00.000Z</published>
    <updated>2024-03-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在做一个 H5 仿新版 QQ 的一个项目，使用的技术栈为 Vue3 + TypeScript + Vite + Pinia + Naive UI</p><p>其中最主要的核心功能就是 WebSocket，建立长连接，实现即时通信效果</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/47.png' /></div><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先在<code>src/utils</code>下新建一个 <code>websocket.ts</code> 文件，里面是封装的 websocket 类（其中部分功能需要根据自己业务需求修改）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebSocketClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">wsurl</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">socketTask</span>: <span class="title class_">WebSocket</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">isConnected</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>; <span class="comment">//是否关闭连接</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">heartbeatIntervalId</span>: <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="built_in">setInterval</span>&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">reconnectTimeoutId</span>: <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="built_in">setTimeout</span>&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    wsurl: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    id: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> heartbeatInterval: <span class="built_in">number</span> = <span class="number">3</span> <span class="comment">//心跳间隔</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">wsurl</span> = wsurl; <span class="comment">// 连接地址</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id; <span class="comment">// 用户id</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">connect</span>(); <span class="comment">// 立即尝试连接</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">connect</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socketTask</span> = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="variable language_">this</span>.<span class="property">wsurl</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socketTask</span>.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebSocket连接成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isConnected</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">startHeartbeat</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socketTask</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">messageEvent</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//写自己收到消息的逻辑</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;接收到WebSocket消息：&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">parse</span>(messageEvent.<span class="property">data</span>));</span><br><span class="line">      <span class="keyword">const</span> newMessage = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(messageEvent.<span class="property">data</span>);</span><br><span class="line">      ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socketTask</span>.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;WebSocket连接错误！&quot;</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isConnected</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socketTask</span>.<span class="property">onclose</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebSocket连接已关闭！&quot;</span>);</span><br><span class="line">      <span class="comment">//判断是否登录逻辑，如果退出登录，断开连接，否则进行重连</span></span><br><span class="line">      <span class="keyword">const</span> isLogin = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;user&quot;</span>) <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">isLogin</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isConnected</span> = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">tryReconnect</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//心跳检测</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">startHeartbeat</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">heartbeatIntervalId</span>) <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">heartbeatIntervalId</span>); <span class="comment">// 清理旧的心跳</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heartbeatIntervalId</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">socketTask</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">isConnected</span>) &#123;</span><br><span class="line">        <span class="comment">//心跳检测消息（看后端需求）</span></span><br><span class="line">        <span class="keyword">const</span> heartbeatMessage = &#123;</span><br><span class="line">          <span class="title class_">Action</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">          <span class="title class_">Sender</span>: <span class="variable language_">this</span>.<span class="property">id</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">socketTask</span>.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(heartbeatMessage));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发送心跳检测消息：&quot;</span>, heartbeatMessage);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="property">heartbeatInterval</span> * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//心跳重连</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">tryReconnect</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">reconnectTimeoutId</span>) <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">reconnectTimeoutId</span>); <span class="comment">// 清理旧的重连</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reconnectTimeoutId</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;尝试重新连接WebSocket...&quot;</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">connect</span>();</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送消息</span></span><br><span class="line">  <span class="title function_">send</span>(<span class="attr">message</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">socketTask</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">isConnected</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">socketTask</span>.<span class="title function_">send</span>(message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;发送失败：WebSocket未连接或已关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭连接</span></span><br><span class="line">  <span class="title function_">close</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">heartbeatIntervalId</span>) <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">heartbeatIntervalId</span>); <span class="comment">// 停止心跳</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">reconnectTimeoutId</span>) <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">reconnectTimeoutId</span>); <span class="comment">// 阻止重连</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">socketTask</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">isConnected</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">socketTask</span>.<span class="title function_">close</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">socketTask</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isConnected</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">WebSocketClass</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">IWebSocket</span> &#123;</span><br><span class="line">  <span class="title function_">send</span>(<span class="attr">message</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">close</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在需要使用的组件中，进行引入，初始化实例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">IWebSocket</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@/model/xxx&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> websocket <span class="keyword">from</span> <span class="string">&quot;@/utils/websocket.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立ws通信</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">ws</span>: <span class="title class_">IWebSocket</span> = <span class="keyword">new</span> <span class="title function_">websocket</span>(</span><br><span class="line">  <span class="string">`ws://xxxx/ws?id=<span class="subst">$&#123;userInfo.uid&#125;</span>`</span>,</span><br><span class="line">  userInfo.<span class="property">uid</span></span><br><span class="line">) <span class="keyword">as</span> <span class="title class_">IWebSocket</span>;</span><br></pre></td></tr></table></figure><p>此时已经建立连接</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/45.png' /></div><p>会自动进行心跳检测</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/46.png' /></div><p>需要进行通信时，调用<code>send()</code>发送消息</p>]]></content>
    
    
    <summary type="html">Vue3中如何使用webscoket，对websocket进行简单封装</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="websocket" scheme="https://munanchun.github.io/tags/websocket/"/>
    
    <category term="vue3" scheme="https://munanchun.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>如何实现单点登录</title>
    <link href="https://munanchun.github.io/posts/c05bacab.html"/>
    <id>https://munanchun.github.io/posts/c05bacab.html</id>
    <published>2024-02-24T16:00:00.000Z</published>
    <updated>2024-02-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、单点登录"><a href="#一、单点登录" class="headerlink" title="一、单点登录"></a>一、单点登录</h2><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一</p><p>SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p><p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过<code>passport</code>，子系统本身将不参与登录操作</p><p>当一个系统成功登录以后，<code>passport</code>将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被<code>passport</code>授权以后，会建立一个局部会话，在一定时间内可以无需再次向<code>passport</code>发起认证</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/39.png' /></div><p>上图有四个系统，分别是<code>Application1</code>、<code>Application2</code>、<code>Application3</code>、和<code>SSO</code>，当<code>Application1</code>、<code>Application2</code>、<code>Application3</code>需要登录时，将跳到<code>SSO</code>系统，<code>SSO</code>系统完成登录，其他的应用系统也就随之登录了</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录</p><h2 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h2><h3 id="同域名下的单点登录"><a href="#同域名下的单点登录" class="headerlink" title="同域名下的单点登录"></a>同域名下的单点登录</h3><p><code>cookie</code>的<code>domain</code>属性设置为当前域的父域，并且父域的<code>cookie</code>会被子域所共享。<code>path</code>属性默认为<code>web</code>应用的上下文路径</p><p>利用 <code>Cookie</code> 的这个特点，没错，我们只需要将<code>Cookie</code>的<code>domain</code>属性设置为父域的域名（主域名），同时将 <code>Cookie</code>的<code>path</code>属性设置为根路径，将 <code>Session ID</code>（或 <code>Token</code>）保存到父域中。这样所有的子域应用就都可以访问到这个<code>Cookie</code></p><p>不过这要求应用系统的域名需建立在一个共同的主域名之下，如 <code>tieba.baidu.com</code> 和 <code>map.baidu.com</code>，它们都建立在 <code>baidu.com</code>这个主域名之下，那么它们就可以通过这种方式来实现单点登录</p><h3 id="不同域名下的单点登录-一"><a href="#不同域名下的单点登录-一" class="headerlink" title="不同域名下的单点登录(一)"></a>不同域名下的单点登录(一)</h3><p>如果是不同域的情况下，<code>Cookie</code>是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 <code>Web</code>服务</p><p>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 <code>token</code> 写入 <code>Cookie</code>（注意这个 <code>Cookie</code>是认证中心的，应用系统是访问不到的）</p><p>应用系统检查当前请求有没有 <code>Token</code>，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心</p><p>由于这个操作会将认证中心的 <code>Cookie</code> 自动带过去，因此，认证中心能够根据 <code>Cookie</code> 知道用户是否已经登录过了</p><p>如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录</p><p>如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 <code>URL</code>，并在跳转前生成一个 <code>Token</code>，拼接在目标<code>URL</code> 的后面，回传给目标应用系统</p><p>应用系统拿到 <code>Token</code>之后，还需要向认证中心确认下 <code>Token</code> 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 <code>Token</code>写入<code>Cookie</code>，然后给本次访问放行。（注意这个 <code>Cookie</code> 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 <code>Token</code>，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了</p><p>此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法</p><h3 id="不同域名下的单点登录-二"><a href="#不同域名下的单点登录-二" class="headerlink" title="不同域名下的单点登录(二)"></a>不同域名下的单点登录(二)</h3><p>可以选择将 <code>Session ID</code> （或 <code>Token</code> ）保存到浏览器的 <code>LocalStorage</code> 中，让前端在每次向后端发送请求时，主动将<code>LocalStorage</code>的数据传递给服务端</p><p>这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 <code>Session ID</code>（或 <code>Token</code>）放在响应体中传递给前端</p><p>单点登录完全可以在前端实现。前端拿到 <code>Session ID</code>（或 <code>Token</code> ）后，除了将它写入自己的 <code>LocalStorage</code> 中之外，还可以通过特殊手段将它写入多个其他域下的 <code>LocalStorage</code> 中</p><p>关键代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 token</span></span><br><span class="line"><span class="keyword">var</span> token = result.<span class="property">data</span>.<span class="property">token</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">iframe.<span class="property">src</span> = <span class="string">&quot;http://app1.com/localstorage.html&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(iframe);</span><br><span class="line"><span class="comment">// 使用postMessage()方法将token传递给iframe</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(token, <span class="string">&quot;http://app1.com&quot;</span>);</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  iframe.<span class="title function_">remove</span>();</span><br><span class="line">&#125;, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;message&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;token&quot;</span>, event.<span class="property">data</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>前端通过 <code>iframe</code>+<code>postMessage()</code> 方式，将同一份 <code>Token</code> 写入到了多个域下的 <code>LocalStorage</code> 中，前端每次在向后端发送请求之前，都会主动从 <code>LocalStorage</code> 中读取<code>Token</code>并在请求中携带，这样就实现了同一份<code>Token</code> 被多个域所共享</p><p>此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域</p><h2 id="三、流程"><a href="#三、流程" class="headerlink" title="三、流程"></a>三、流程</h2><p>单点登录的流程图如下所示：</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/40.png' /></div><ul><li>用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li><li>sso 认证中心发现用户未登录，将用户引导至登录页面</li><li>用户输入用户名密码提交登录申请</li><li>sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌</li><li>sso 认证中心带着令牌跳转会最初的请求地址（系统 1）</li><li>系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效</li><li>sso 认证中心校验令牌，返回有效，注册系统 1</li><li>系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li><li>用户访问系统 2 的受保护资源</li><li>系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li><li>sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌</li><li>系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效</li><li>sso 认证中心校验令牌，返回有效，注册系统 2</li><li>系统 2 使用该令牌创建与用户的局部会话，返回受保护资源</li></ul><p>用户登录成功之后，会与<code>sso</code>认证中心及各个子系统建立会话，用户与<code>sso</code>认证中心建立的会话称为全局会话</p><p>用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过<code>sso</code>认证中心</p><p>全局会话与局部会话有如下约束关系：</p><ul><li>局部会话存在，全局会话一定存在</li><li>全局会话存在，局部会话不一定存在</li><li>全局会话销毁，局部会话必须销毁</li></ul>]]></content>
    
    
    <summary type="html">如何实现单点登录</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="单点登录" scheme="https://munanchun.github.io/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>事件循环</title>
    <link href="https://munanchun.github.io/posts/b8084239.html"/>
    <id>https://munanchun.github.io/posts/b8084239.html</id>
    <published>2024-02-07T16:00:00.000Z</published>
    <updated>2024-02-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器进程模型"><a href="#浏览器进程模型" class="headerlink" title="浏览器进程模型"></a>浏览器进程模型</h2><p>了解事件循环之前，首先了解一下浏览器进程模型</p><h3 id="何为进程？"><a href="#何为进程？" class="headerlink" title="何为进程？"></a>何为进程？</h3><p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解 为进程</p><div class='blog-img'>  <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/48.png' /></div><p>每个应用至少有⼀个进程，进程之间相互独立，即使要通信，也需要双方同意。</p><h3 id="何为线程？"><a href="#何为线程？" class="headerlink" title="何为线程？"></a>何为线程？</h3><p>有了进程后，就可以运行程序的代码了。 运⾏代码的「⼈」称之为「线程」。</p><p>⼀个进程至少有⼀个线程，所以在进程开启后会自动创建⼀个线程来运行代码，该线程称之为<code>主线程</code>。</p><p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以⼀个进程中可以包含多个线程。</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/49.png' /></div><h3 id="浏览器有哪些进程和线程？"><a href="#浏览器有哪些进程和线程？" class="headerlink" title="浏览器有哪些进程和线程？"></a>浏览器有哪些进程和线程？</h3><p><strong>浏览器是⼀个多进程多线程的应⽤程序</strong></p><p>浏览器内部工作极其复杂。</p><p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/50.png' /></div><blockquote><p>可以在浏览器的任务管理器中查看当前的所有进程</p></blockquote><p>其中，最主要的进程有:</p><ol><li>浏览器进程<br>主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</li><li>网络进程<br>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务</li><li>渲染进程*<br>渲染进程启动后，会开启一个<code>渲染主线程</code>，主线程负责执行 HTML、CSSJS 代码。<br>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</li></ol><h2 id="渲染主线程是如何工作的？"><a href="#渲染主线程是如何工作的？" class="headerlink" title="渲染主线程是如何工作的？"></a>渲染主线程是如何工作的？</h2><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p><ul><li>解析 HTML</li><li>解析 CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把页面画 60 次</li><li>执行全局 JS 代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>……</li></ul><p>要处理这么多的任务，主线程遇到了一个前所未有的难题: <strong>如何调度任务?</strong></p><p>比如:</p><ul><li>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗?</li><li>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗?</li><li>浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢?</li><li>……</li></ul><p>渲染主线程想出了一个绝妙的主意来处理这个问题：<code>排队</code></p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/51.png' /></div><ol><li>在最开始的时候，渲染主线程会进入一个无限循环</li><li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环;如果没有，则进入休眠状态</li><li>其他所有线程 (包括其他进程的线程) 可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li></ol><p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了</p><p><strong>整个过程，被称之为事件循环 (消息循环)</strong></p><h3 id="何为异步？"><a href="#何为异步？" class="headerlink" title="何为异步？"></a>何为异步？</h3><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如:</p><ul><li>计时完成后需要执行的任务 —<code>setTimeout</code>、<code>setInterval</code></li><li>网络通信完成后需要执行的任务— <code>XHR</code>、<code>Fetch</code></li><li>用户操作后需要执行的任务 — <code>addEventListener</code></li></ul><p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于<code>「阻塞」</code>的状态，从而导致浏览器 <code>「卡死」</code></p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/52.png' /></div><p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong></p><p>因此，浏览器选择<strong>异步</strong>来解决这个问题</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/53.png' /></div><p>使用异步的方式，<strong>渲染主线程永不阻塞</strong></p><h3 id="任务有优先级吗？"><a href="#任务有优先级吗？" class="headerlink" title="任务有优先级吗？"></a>任务有优先级吗？</h3><p>任务没有优先级，在消息队列中先进先出</p><p>但<strong>消息队列是有优先级的</strong></p><p>根据 W3C 的最新解释:</p><ul><li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li><li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></li></ul><blockquote><p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p></blockquote><p>在目前 chrome 的实现中，至少包含了下面的队列:</p><ul><li>延时队列：用于存放计时器到达后的回调任务，优先级<code>「中」</code></li><li>交互队列：用于存放用户操作后产生的事件处理任务，优先级<code>「高」</code></li><li>微队列：用户存放需要最快执行的任务，优先级<code>「最高」</code></li></ul><blockquote><p>添加任务到微队列的主要方式是使用 Promise、MutationObserver</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//立即把一个函数添加到微队列</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolive</span>().<span class="title function_">then</span>(函数);</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">浏览器事件循环那些事</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="事件循环" scheme="https://munanchun.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>大文件上传如何实现断点续传</title>
    <link href="https://munanchun.github.io/posts/8960ba38.html"/>
    <id>https://munanchun.github.io/posts/8960ba38.html</id>
    <published>2024-02-04T16:00:00.000Z</published>
    <updated>2024-02-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂</p><p>文件上传简单，文件变大就复杂</p><p>上传大文件时，以下几个变量会影响我们的用户体验</p><ul><li>服务器处理数据的能力</li><li>请求超时</li><li>网络波动</li></ul><p>上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等</p><p>为了解决上述问题，我们需要对大文件上传单独处理</p><p>这里涉及到分片上传及断点续传两个概念</p><h4 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h4><p>分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传</p><p>如下图</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/37.png' /></div><p>上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件</p><p>大致流程如下：</p><ol><li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li><li>初始化一个分片上传任务，返回本次分片上传唯一标识；</li><li>按照一定的策略（串行或并行）发送各个分片数据块；</li><li>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件</li></ol><h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><p>断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分</p><p>每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度</p><p>一般实现方式有两种：</p><ul><li>服务器端返回，告知从哪开始</li><li>浏览器端自行处理</li></ul><p>上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可</p><p>如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可</p><h2 id="二、实现思路"><a href="#二、实现思路" class="headerlink" title="二、实现思路"></a>二、实现思路</h2><p>整体思路比较简单，拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/38.png' /></div><p>下面的内容都是伪代码</p><p>读取文件内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> file = <span class="variable language_">this</span>.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以使用<code>md5</code>实现文件的唯一性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> md5code = <span class="title function_">md5</span>(file);</span><br></pre></td></tr></table></figure><p>然后开始对文件进行分割</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">reader.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//每10M切割一段,这里只做一个切割演示，实际切割需要循环切割，</span></span><br><span class="line">  <span class="keyword">var</span> slice = e.<span class="property">target</span>.<span class="property">result</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>h5 上传一个（一片）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formdata = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&quot;0&quot;</span>, slice);</span><br><span class="line"><span class="comment">//这里是有一个坑的，部分设备无法获取文件名称，和文件类型，这个在最后给出解决方案</span></span><br><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&quot;filename&quot;</span>, file.<span class="property">filename</span>);</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//xhr.responseText</span></span><br><span class="line">&#125;);</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(formdata);</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&quot;progress&quot;</span>, updateProgress);</span><br><span class="line">xhr.<span class="property">upload</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;progress&quot;</span>, updateProgress);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">    <span class="comment">//进度条</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出常见的图片和视频的文件类型判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkFileType</span>(<span class="params">type, file, back</span>) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * type png jpg mp4 ...</span></span><br><span class="line"><span class="comment">   * file input.change=&gt; this.files[0]</span></span><br><span class="line"><span class="comment">   * back callback(boolean)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">  <span class="keyword">if</span> (args.<span class="property">length</span> != <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="title function_">back</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> type = args[<span class="number">0</span>]; <span class="comment">// type = &#x27;(png|jpg)&#x27; , &#x27;png&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> file = args[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">var</span> back = <span class="keyword">typeof</span> args[<span class="number">2</span>] == <span class="string">&quot;function&quot;</span> ? args[<span class="number">2</span>] : <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (file.<span class="property">type</span> == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果系统无法获取文件类型，则读取二进制流，对二进制进行解析文件类型</span></span><br><span class="line">    <span class="keyword">var</span> imgType = [</span><br><span class="line">      <span class="string">&quot;ff d8 ff&quot;</span>, <span class="comment">//jpg</span></span><br><span class="line">      <span class="string">&quot;89 50 4e&quot;</span>, <span class="comment">//png</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;0 0 0 14 66 74 79 70 69 73 6F 6D&quot;</span>, <span class="comment">//mp4</span></span><br><span class="line">      <span class="string">&quot;0 0 0 18 66 74 79 70 33 67 70 35&quot;</span>, <span class="comment">//mp4</span></span><br><span class="line">      <span class="string">&quot;0 0 0 0 66 74 79 70 33 67 70 35&quot;</span>, <span class="comment">//mp4</span></span><br><span class="line">      <span class="string">&quot;0 0 0 0 66 74 79 70 4D 53 4E 56&quot;</span>, <span class="comment">//mp4</span></span><br><span class="line">      <span class="string">&quot;0 0 0 0 66 74 79 70 69 73 6F 6D&quot;</span>, <span class="comment">//mp4</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;0 0 0 18 66 74 79 70 6D 70 34 32&quot;</span>, <span class="comment">//m4v</span></span><br><span class="line">      <span class="string">&quot;0 0 0 0 66 74 79 70 6D 70 34 32&quot;</span>, <span class="comment">//m4v</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;0 0 0 14 66 74 79 70 71 74 20 20&quot;</span>, <span class="comment">//mov</span></span><br><span class="line">      <span class="string">&quot;0 0 0 0 66 74 79 70 71 74 20 20&quot;</span>, <span class="comment">//mov</span></span><br><span class="line">      <span class="string">&quot;0 0 0 0 6D 6F 6F 76&quot;</span>, <span class="comment">//mov</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;4F 67 67 53 0 02&quot;</span>, <span class="comment">//ogg</span></span><br><span class="line">      <span class="string">&quot;1A 45 DF A3&quot;</span>, <span class="comment">//ogg</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;52 49 46 46 x x x x 41 56 49 20&quot;</span>, <span class="comment">//avi (RIFF fileSize fileType LIST)(52 49 46 46,DC 6C 57 09,41 56 49 20,4C 49 53 54)</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">var</span> typeName = [</span><br><span class="line">      <span class="string">&quot;jpg&quot;</span>,</span><br><span class="line">      <span class="string">&quot;png&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mp4&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mp4&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mp4&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mp4&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mp4&quot;</span>,</span><br><span class="line">      <span class="string">&quot;m4v&quot;</span>,</span><br><span class="line">      <span class="string">&quot;m4v&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mov&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mov&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mov&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ogg&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ogg&quot;</span>,</span><br><span class="line">      <span class="string">&quot;avi&quot;</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">var</span> sliceSize = <span class="regexp">/png|jpg|jpeg/</span>.<span class="title function_">test</span>(type) ? <span class="number">3</span> : <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">    reader.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> slice = e.<span class="property">target</span>.<span class="property">result</span>.<span class="title function_">slice</span>(<span class="number">0</span>, sliceSize);</span><br><span class="line">      reader = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (slice &amp;&amp; slice.<span class="property">byteLength</span> == sliceSize) &#123;</span><br><span class="line">        <span class="keyword">var</span> view = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(slice);</span><br><span class="line">        <span class="keyword">var</span> arr = [];</span><br><span class="line">        view.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">          arr.<span class="title function_">push</span>(v.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        view = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">var</span> idx = arr.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">indexOf</span>(imgType);</span><br><span class="line">        <span class="keyword">if</span> (idx &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="title function_">back</span>(typeName[idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          arr = arr.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">3</span> &amp;&amp; i &lt; <span class="number">8</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;x&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">var</span> idx = arr.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">indexOf</span>(imgType);</span><br><span class="line">          <span class="keyword">if</span> (idx &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title function_">back</span>(typeName[idx]);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">back</span>(<span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">back</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> type = file.<span class="property">name</span>.<span class="title function_">match</span>(<span class="regexp">/\.(\w+)$/</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="title function_">back</span>(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">checkFileType</span>(<span class="string">&quot;(mov|mp4|avi)&quot;</span>, file, <span class="keyword">function</span> (<span class="params">fileType</span>) &#123;</span><br><span class="line">  <span class="comment">// fileType = mp4,</span></span><br><span class="line">  <span class="comment">// 如果file的类型不在枚举之列，则返回false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面上传文件的一步，可以改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&quot;filename&quot;</span>, md5code + <span class="string">&quot;.&quot;</span> + fileType);</span><br></pre></td></tr></table></figure><p>有了切割上传后，也就有了文件唯一标识信息，断点续传变成了后台的一个小小的逻辑判断</p><p>后端主要做的内容为：根据前端传给后台的<code>md5</code>值，到服务器磁盘查找是否有之前未完成的文件合并信息（也就是未完成的半成品文件切片），取到之后根据上传切片的数量，返回数据告诉前端开始从第几节上传</p><p>如果想要暂停切片的上传，可以使用<code>XMLHttpRequest</code>的 <code>abort</code>方法</p><h2 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h2><ul><li>大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度</li><li>网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的 Part</li><li>流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见</li></ul>]]></content>
    
    
    <summary type="html">大文件上传如何实现断点续传</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="文件上传" scheme="https://munanchun.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>几个非常实用的Chrome Devtools 技巧</title>
    <link href="https://munanchun.github.io/posts/5b49117f.html"/>
    <id>https://munanchun.github.io/posts/5b49117f.html</id>
    <published>2024-01-02T10:30:12.000Z</published>
    <updated>2024-01-02T10:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于 Chrome 浏览器，如果你是一名前端开发者，相信对此并不陌生，我们可以用它来查看 <code>网络请求</code>、<code>分析网页性能</code>、<code>调试 JavaScript 功能</code> 等。</p><p>除了这些，它还提供了很多强大但不常见的功能，可以大大提高我们的开发效率，这里分享几个实用的技巧</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="控制台导入器"><a href="#控制台导入器" class="headerlink" title="控制台导入器"></a>控制台导入器</h3><p>有时候想用某些库的 API，但又懒得去官网查，可以直接在控制台尝试。</p><p>要先安装 <code>Console Importer</code>，否则会报如下错误：</p><p><img src="https://bu.dusays.com/2023/10/17/652df925e7f18.jpg" alt=" "></p><p>安装插件后，重启浏览器即可体验效果。</p><div class='blog-img'> <img src='https://bu.dusays.com/2023/10/17/652df3bce365c.jpg' /></div><div class='blog-img'> <img src='https://bu.dusays.com/2023/10/17/652df9e3b8cd6.jpg' /></div><h3 id="添加条件断点"><a href="#添加条件断点" class="headerlink" title="添加条件断点"></a>添加条件断点</h3><p>通过下面的代码，希望当名字是 <code>鸡太美</code> 时 触发断点，该如何实现呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> persons = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;蔡徐坤&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;菜虚鲲&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;鸡太美&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line">persons.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//   debugger</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v.<span class="property">name</span>, v.<span class="property">age</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在数据量很大的情况下，使用 <code>条件断点</code> 对开发工作很有帮助，大大提高效率。</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/clutter/1.gif' /></div><h3 id="使用-“-”-引用上次执行的结果"><a href="#使用-“-”-引用上次执行的结果" class="headerlink" title="使用 “$” 引用上次执行的结果"></a>使用 “<code>$</code>” 引用上次执行的结果</h3><p>类似下面的场景，如果你对字符串进行了各种操作后，又想知道每一步的结果，该怎么做呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;ikun1997&quot;</span>.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 7991nuki</span></span><br></pre></td></tr></table></figure><p>你可能会这样做:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1</span></span><br><span class="line"><span class="string">&quot;ikun1997&quot;</span></span><br><span class="line">  .<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// [&#x27;i&#x27;, &#x27;k&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;9&#x27;, &#x27;7&#x27;]</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// step 2</span></span><br><span class="line">    (<span class="string">&quot;i&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">  ].<span class="title function_">reverse</span>() <span class="comment">//  [&#x27;7&#x27;, &#x27;9&#x27;, &#x27;9&#x27;, &#x27;1&#x27;, &#x27;n&#x27;, &#x27;u&#x27;, &#x27;k&#x27;, &#x27;i&#x27;]</span></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// step 3</span></span><br><span class="line">    (<span class="string">&quot;7&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;i&quot;</span>)</span><br><span class="line">  ].<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 7991nuki</span></span><br></pre></td></tr></table></figure><div class='blog-img'> <img src='https://bu.dusays.com/2023/10/17/652dfc7db96d1.jpg' /></div><p>使用 “$” 获取上一次操作的结果，无需每次都复制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1</span></span><br><span class="line"><span class="string">&quot;ikun1997&quot;</span>.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// [&#x27;i&#x27;, &#x27;k&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;9&#x27;, &#x27;7&#x27;]</span></span><br><span class="line"><span class="comment">// step 2</span></span><br><span class="line">$_.<span class="title function_">reverse</span>(); <span class="comment">// [&#x27;7&#x27;, &#x27;9&#x27;, &#x27;9&#x27;, &#x27;1&#x27;, &#x27;n&#x27;, &#x27;u&#x27;, &#x27;k&#x27;, &#x27;i&#x27;]</span></span><br><span class="line"><span class="comment">// step 3</span></span><br><span class="line">$_.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 7991nuki</span></span><br></pre></td></tr></table></figure><div class='blog-img'> <img src='https://bu.dusays.com/2023/10/17/652dfe986c34b.jpg' /></div><h3 id="展开所有子节点"><a href="#展开所有子节点" class="headerlink" title="展开所有子节点"></a>展开所有子节点</h3><p>如何一次展开 DOM 元素的所有子节点，聪明的你会一个个的展开吗？</p><p>当然使用 <code>Alt + 单击</code> 一次展开所有子节点啦</p><div class='blog-img'> <img src='https://bu.dusays.com/2023/10/17/652e02df46bf1.gif' /></div><p>在 gif 中 显而易见，点击一次只展开了一个子节点，<code>Alt + 单击</code> 则展开所有子节点。</p><h3 id="使用-“-quot-和-quot-”-快速选择-DOM-元素"><a href="#使用-“-quot-和-quot-”-快速选择-DOM-元素" class="headerlink" title="使用 “$$&quot; 和 &quot;$$$” 快速选择 DOM 元素"></a>使用 “$$<code>&quot; 和 &quot;</code>$$$” 快速选择 DOM 元素</h3><p>使用 <code>document.querySelector</code> 和 <code>document.querySelectorAll</code> 在控制台中选择当前页面的元素是最常见的需求，单词太长，我们可以使用 $$<code>和</code>$$$ 来代替。</p><div class='blog-img'> <img src='https://bu.dusays.com/2023/10/17/652e02cc053e3.jpg' /></div><h3 id="在控制台重新发送请求"><a href="#在控制台重新发送请求" class="headerlink" title="在控制台重新发送请求"></a>在控制台重新发送请求</h3><p>对于同一个请求，有时需要重新发送，这时可以这样做:</p><p>1.选择 Network 面板 中的 <code>Fetch/XHR</code> 2.选中要重新发送的请求，<code>Replay XHR</code></p><div class='blog-img'> <img src='https://bu.dusays.com/2023/10/17/652e3407a53f9.gif' /></div><h3 id="在控制台发送修改参数后的请求"><a href="#在控制台发送修改参数后的请求" class="headerlink" title="在控制台发送修改参数后的请求"></a>在控制台发送修改参数后的请求</h3><p>对于同一个请求，有时需要 <code>修改某些参数</code> 并重新发送，这时可以这样做:</p><p>1.选择 Network 面板 中的 <code>Fetch/XHR</code></p><p>2.选中要重新发送的请求，<strong>Copy as fetch</strong></p><p>3.修改参数并发送</p><div class='blog-img'> <img src='https://bu.dusays.com/2023/10/17/652e311619cf7.gif' /></div><blockquote><p>原文链接 <a href="https://fe32.top/articles/skill001/">几个非常实用的 Chrome Devtools 技巧</a></p></blockquote>]]></content>
    
    
    <summary type="html">几个非常实用的Chrome Devtools 技巧</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="调试" scheme="https://munanchun.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染页面</title>
    <link href="https://munanchun.github.io/posts/d89b32c6.html"/>
    <id>https://munanchun.github.io/posts/d89b32c6.html</id>
    <published>2023-12-19T16:00:00.000Z</published>
    <updated>2023-12-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p><hr><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><hr><h3 id="解析-HTML"><a href="#解析-HTML" class="headerlink" title="解析 HTML"></a>解析 HTML</h3><p>渲染的第一步是<strong>解析 HTML</strong>。</p><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><hr><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>渲染的下一步是<strong>样式计算</strong>。</p><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p><hr><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><hr><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>下一步是<strong>分层</strong></p><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><hr><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>再下一步是<strong>绘制</strong></p><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><hr><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p><hr><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>分块完成后，进入<strong>光栅化</strong>阶段。</p><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图</p><hr><h3 id="画"><a href="#画" class="headerlink" title="画"></a>画</h3><p>最后一个阶段就是<strong>画</strong>了</p><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><h2 id="reflow（重排）"><a href="#reflow（重排）" class="headerlink" title="reflow（重排）"></a>reflow（重排）</h2><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h2 id="repaint（重绘）"><a href="#repaint（重绘）" class="headerlink" title="repaint（重绘）"></a>repaint（重绘）</h2><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h2 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h2><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>]]></content>
    
    
    <summary type="html">浏览器是怎么渲染页面的？</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="css" scheme="https://munanchun.github.io/tags/css/"/>
    
    <category term="浏览器" scheme="https://munanchun.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Vue中后台管理系统使用echarts，侧边栏变化导致图表不能自适应问题</title>
    <link href="https://munanchun.github.io/posts/a9195f79.html"/>
    <id>https://munanchun.github.io/posts/a9195f79.html</id>
    <published>2023-12-04T16:00:00.000Z</published>
    <updated>2023-12-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;&emsp;在做一个后台管理系统时遇到了这个问题，当左侧列表展开时就会使 echarts 图表溢出或空缺，echarts 配置的响应式只响应窗口变化，并不能支持内部变化导致的内容溢出或空缺，如图两种情况</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/17.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/18.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/19.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/20.webp" /></div><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li><p>首先需要引入<code>element-resize-detector</code>依赖</p></li><li><p>新建 <code>chart.resize.js</code> 文件，添加下面代码，配置自定义指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">&quot;echarts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> elementResizeDetectorMaker <span class="keyword">from</span> <span class="string">&quot;element-resize-detector&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> version = <span class="string">&quot;0.0.1&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> compatible = <span class="regexp">/^2\./</span>.<span class="title function_">test</span>(<span class="title class_">Vue</span>.<span class="property">version</span>);</span><br><span class="line"><span class="keyword">if</span> (!compatible) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">util</span>.<span class="title function_">warn</span>(</span><br><span class="line">    <span class="string">&quot;vue echarts resize directive &quot;</span> +</span><br><span class="line">      version +</span><br><span class="line">      <span class="string">&quot; only supports Vue 2.x, and does not support Vue &quot;</span> +</span><br><span class="line">      <span class="title class_">Vue</span>.<span class="property">version</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">HANDLER</span> = <span class="string">&quot;_vue_echarts_resize_handler&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="title function_">unbind</span>(el);</span><br><span class="line">  el[<span class="variable constant_">HANDLER</span>] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> chart = echarts.<span class="title function_">getInstanceByDom</span>(el);</span><br><span class="line">    <span class="keyword">if</span> (!chart) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chart.<span class="title function_">resize</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//监听window窗体变化，更新echarts大小</span></span><br><span class="line">  <span class="comment">//window.addEventListener(&quot;resize&quot;, el[HANDLER])</span></span><br><span class="line">  <span class="comment">//监听绑定的div大小变化，更新echarts大小</span></span><br><span class="line">  <span class="title function_">elementResizeDetectorMaker</span>().<span class="title function_">listenTo</span>(el, el[<span class="variable constant_">HANDLER</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unbind</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="comment">//window.removeEventListener(&quot;resize&quot;, el[HANDLER]);</span></span><br><span class="line">  <span class="title function_">elementResizeDetectorMaker</span>().<span class="title function_">removeListener</span>(el, el[<span class="variable constant_">HANDLER</span>]);</span><br><span class="line">  <span class="keyword">delete</span> el[<span class="variable constant_">HANDLER</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> directive = &#123;</span><br><span class="line">  <span class="attr">bind</span>: bind,</span><br><span class="line">  <span class="attr">unbind</span>: unbind,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;on-echart-resize&quot;</span>, directive);</span><br></pre></td></tr></table></figure></li><li><p>在页面中引入依赖以及 js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> elementResizeDetectorMaker <span class="keyword">from</span> <span class="string">&quot;element-resize-detector&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./chart.resize&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>在需要监听的 echarts 的 dom 容器中绑定指令<code>v-on-echart-resize</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">&quot;tendencyChart&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;tendencyChart&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;width: 100%; height: 160px&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on-echart-resize</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>mounted</code>中进行监听，从而解决菜单栏问题导致的 echarts 图表不能自适应问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 左侧导航菜单打开与关闭，echarts实现响应式</span></span><br><span class="line">    <span class="keyword">let</span> erd = <span class="title function_">elementResizeDetectorMaker</span>();</span><br><span class="line">    <span class="keyword">let</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 监听折线图大小变化，使echarts发生响应式变化</span></span><br><span class="line">    erd.<span class="title function_">listenTo</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tendencyChart&quot;</span>), <span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">      that.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//使echarts尺寸重置</span></span><br><span class="line">        that.<span class="property">echarts</span>.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tendencyChart&quot;</span>)).<span class="title function_">resize</span>();</span><br><span class="line">        ...<span class="comment">//如果多个都需要改变，可以在这里添加多个echarts（id为tendencyChart的图表尺寸发生改变时，写入的echartst图表都跟着改变）</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ol><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/21.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/22.webp" /></div>]]></content>
    
    
    <summary type="html">侧边栏伸缩导致echarts无法自适应问题</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="vue" scheme="https://munanchun.github.io/tags/vue/"/>
    
    <category term="数据可视化" scheme="https://munanchun.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="适配" scheme="https://munanchun.github.io/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>浅谈设备像素、css像素、设备独立像素、dpr之间的区别</title>
    <link href="https://munanchun.github.io/posts/73b02dc6.html"/>
    <id>https://munanchun.github.io/posts/73b02dc6.html</id>
    <published>2023-11-19T16:00:00.000Z</published>
    <updated>2023-11-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>在<code>css</code>中我们通常使用 px 作为单位，在 PC 浏览器中<code>css</code>的 1 个像素都是对应着电脑屏幕的 1 个物理像素</p><p>这会造成一种错觉，我们会认为<code>css</code>中的像素就是设备的物理像素</p><p>但实际情况却并非如此，<code>css</code>中的像素只是一个抽象的单位，在不同的设备或不同的环境中，<code>css</code>中的 1px 所代表的设备物理像素是不同的</p><p>当我们做移动端开发时，同为 1px 的设置，在不同分辨率的移动设备上显示效果却有很大差异</p><p>这背后就涉及了 css 像素、设备像素、设备独立像素、dpr、ppi 的概念</p><h2 id="二、介绍"><a href="#二、介绍" class="headerlink" title="二、介绍"></a>二、介绍</h2><h3 id="CSS-像素"><a href="#CSS-像素" class="headerlink" title="CSS 像素"></a>CSS 像素</h3><p>CSS 像素（css pixel, px）: 适用于 web 编程，在 CSS 中以 px 为后缀，是一个长度单位</p><p>在 CSS 规范中，长度单位可以分为两类，绝对单位以及相对单位</p><p>px 是一个相对单位，相对的是设备像素（device pixel）</p><p>一般情况，页面缩放比为 1，1 个 CSS 像素等于 1 个设备独立像素</p><p><code>CSS</code>像素又具有两个方面的相对性：</p><ul><li>在同一个设备上，每 1 个 CSS 像素所代表的设备像素是可以变化的（比如调整屏幕的分辨率）</li><li>在不同的设备之间，每 1 个 CSS 像素所代表的设备像素是可以变化的（比如两个不同型号的手机）</li></ul><p>在页面进行缩放操作也会 引起<code>css</code>中<code>px</code>的变化，假设页面放大一倍，原来的 1px 的东西变成 2px，在实际宽度不变的情况下 1px 变得跟原来的 2px 的长度（长宽）一样了（元素会占据更多的设备像素）</p><p>假设原来需要 320px 才能填满的宽度现在只需要 160px</p><p>px 会受到下面的因素的影响而变化：</p><ul><li>每英寸像素（PPI）</li><li>设备像素比（DPR）</li></ul><h3 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h3><p>设备像素（device pixels），又称为物理像素</p><p>指设备能控制显示的最小物理单位，不一定是一个小正方形区块，也没有标准的宽高，只是用于显示丰富色彩的一个“点”而已</p><p>可以参考公园里的景观变色彩灯，一个彩灯(物理像素)由红、蓝、绿小灯组成，三盏小灯不同的亮度混合出各种色彩</p><div class='blog-img'>  <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/41.png' /></div><p>从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，单位为<code>pt</code></p><h3 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h3><p>设备独立像素（Device Independent Pixel）：与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了 CSS 像素</p><p>在<code>javaScript</code>中可以通过<code>window.screen.width/ window.screen.height</code> 查看</p><p>比如我们会说“电脑屏幕在 2560x1600 分辨率下不适合玩游戏，我们把它调为 1440x900”，这里的“分辨率”（非严谨说法）指的就是设备独立像素</p><p>一个设备独立像素里可能包含 1 个或者多个物理像素点，包含的越多则屏幕看起来越清晰</p><p>至于为什么出现设备独立像素这种虚拟像素单位概念，下面举个例子：</p><p>iPhone 3GS 和 iPhone 4/4s 的尺寸都是 3.5 寸，但 iPhone 3GS 的分辨率是 320x480，iPhone 4/4s 的分辨率是 640x960</p><p>这意味着，iPhone 3GS 有 320 个物理像素，iPhone 4/4s 有 640 个物理像素</p><p>如果我们按照真实的物理像素进行布局，比如说我们按照 320 物理像素进行布局，到了 640 物理像素的手机上就会有一半的空白，为了避免这种问题，就产生了虚拟像素单位</p><p>我们统一 iPhone 3GS 和 iPhone 4/4s 都是 320 个虚拟像素，只是在 iPhone 3GS 上，最终 1 个虚拟像素换算成 1 个物理像素，在 iphone 4s 中，1 个虚拟像素最终换算成 2 个物理像素</p><p>至于 1 个虚拟像素被换算成几个物理像素，这个数值我们称之为设备像素比，也就是下面介绍的<code>dpr</code></p><h3 id="dpr"><a href="#dpr" class="headerlink" title="dpr"></a>dpr</h3><p>dpr（device pixel ratio），设备像素比，代表设备独立像素到设备像素的转换关系，在<code>JavaScript</code>中可以通过 <code>window.devicePixelRatio</code> 获取</p><p>计算公式如下：</p><div class='blog-img'>  <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/42.png' /></div><p>当设备像素比为 1:1 时，使用 1（1×1）个设备像素显示 1 个 CSS 像素</p><p>当设备像素比为 2:1 时，使用 4（2×2）个设备像素显示 1 个 CSS 像素</p><p>当设备像素比为 3:1 时，使用 9（3×3）个设备像素显示 1 个 CSS 像素</p><p>如下图所示：</p><div class='blog-img'>  <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/43.png' /></div><p>当<code>dpr</code>为 3，那么<code>1px</code>的<code>CSS</code>像素宽度对应<code>3px</code>的物理像素的宽度，1px 的<code>CSS</code>像素高度对应<code>3px</code>的物理像素高度</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>无缩放情况下，1 个 CSS 像素等于 1 个设备独立像素</p><p>设备像素由屏幕生产之后就不发生改变，而设备独立像素是一个虚拟单位会发生改变</p><p>PC 端中，1 个设备独立像素 = 1 个设备像素 （在 100%，未缩放的情况下）</p><p>在移动端中，标准屏幕（160ppi）下 1 个设备独立像素 = 1 个设备像素</p><p>设备像素比（dpr） = 设备像素 / 设备独立像素</p>]]></content>
    
    
    <summary type="html">浅谈设备像素、css像素、设备独立像素、dpr之间的区别</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="css" scheme="https://munanchun.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Vue3</title>
    <link href="https://munanchun.github.io/posts/3a42db2d.html"/>
    <id>https://munanchun.github.io/posts/3a42db2d.html</id>
    <published>2023-11-10T13:19:00.000Z</published>
    <updated>2023-11-10T13:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><p><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" /></p><h3 id="1-Vue3-简介"><a href="#1-Vue3-简介" class="headerlink" title="1.Vue3 简介"></a>1.Vue3 简介</h3><ul><li>2020 年 9 月 18 日，Vue.js 发布 3.0 版本，代号：One Piece（海贼王）</li><li>耗时 2 年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个 RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+">600+次 PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99 位贡献者</a></li><li>github 上的 tags 地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h3 id="2-Vue3-带来了什么"><a href="#2-Vue3-带来了什么" class="headerlink" title="2.Vue3 带来了什么"></a>2.Vue3 带来了什么</h3><h4 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h4><ul><li><p>打包大小减少 41%</p></li><li><p>初次渲染快 55%, 更新渲染快 133%</p></li><li><p>内存减少 54%</p><p>……</p></li></ul><h4 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h4><ul><li><p>使用 Proxy 代替 defineProperty 实现响应式</p></li><li><p>重写虚拟 DOM 的实现和 Tree-Shaking</p><p>……</p></li></ul><h4 id="3-拥抱-TypeScript"><a href="#3-拥抱-TypeScript" class="headerlink" title="3.拥抱 TypeScript"></a>3.拥抱 TypeScript</h4><ul><li>Vue3 可以更好的支持 TypeScript</li></ul><h4 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h4><ol><li><p>Composition API（组合 API）</p><ul><li>setup 配置</li><li>ref 与 reactive</li><li>watch 与 watchEffect</li><li>provide 与 inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment</li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除 keyCode 支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h2 id="一、创建-Vue3-0-工程"><a href="#一、创建-Vue3-0-工程" class="headerlink" title="一、创建 Vue3.0 工程"></a>一、创建 Vue3.0 工程</h2><h3 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h3><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h3 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h3><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite 官网：<a href="https://vitejs.cn">https://vitejs.cn</a></p><ul><li>什么是 vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite 构建对比图</li></ul><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/10.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/11.webp" /></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h2><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h3 id="1-拉开序幕的-setup"><a href="#1-拉开序幕的-setup" class="headerlink" title="1.拉开序幕的 setup"></a>1.拉开序幕的 setup</h3><ol><li>理解：Vue3.0 中一个新的配置项，值为一个函数。</li><li>setup 是所有<strong style="color:#DD5145">Composition API（组合 API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在 setup 中。</li><li>setup 函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与 Vue2.x 配置混用<ul><li>Vue2.x 配置（data、methods、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup 中的属性、方法。</li><li>但在 setup 中<strong style="color:#DD5145">不能访问到</strong>Vue2.x 配置（data、methods、computed…）。</li><li>如果有重名, setup 优先。</li></ul></li><li>setup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）</li></ol></li></ol><h3 id="2-ref-函数"><a href="#2-ref-函数" class="headerlink" title="2.ref 函数"></a>2.ref 函数</h3><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code><ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference 对象，简称 ref 对象）</strong>。</li><li>JS 中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了 Vue3.0 中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h3 id="3-reactive-函数"><a href="#3-reactive-函数" class="headerlink" title="3.reactive 函数"></a>3.reactive 函数</h3><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy 的实例对象，简称 proxy 对象）</strong></li><li>reactive 定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h3 id="4-Vue3-0-中的响应式原理"><a href="#4-Vue3-0-中的响应式原理" class="headerlink" title="4.Vue3.0 中的响应式原理"></a>4.Vue3.0 中的响应式原理</h3><h4 id="vue2-x-的响应式"><a href="#vue2-x-的响应式" class="headerlink" title="vue2.x 的响应式"></a>vue2.x 的响应式</h4><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&quot;count&quot;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h4 id="Vue3-0-的响应式"><a href="#Vue3-0-的响应式" class="headerlink" title="Vue3.0 的响应式"></a>Vue3.0 的响应式</h4><ul><li><p>实现原理:</p><ul><li>通过 Proxy（代理）: 拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等。</li><li><p>通过 Reflect（反射）: 对源对象的属性进行操作。</p><ul><li><p>MDN 文档中描述的 Proxy 与 Reflect：</p><ul><li>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></li><li>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 拦截读取属性值</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截删除属性</span></span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&quot;tom&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="5-reactive-对比-ref"><a href="#5-reactive-对比-ref" class="headerlink" title="5.reactive 对比 ref"></a>5.reactive 对比 ref</h3><ul><li>从定义数据角度对比：<ul><li>ref 用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive 用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref 也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref 通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive 通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref 定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive 定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h3 id="6-setup-的两个注意点"><a href="#6-setup-的两个注意点" class="headerlink" title="6.setup 的两个注意点"></a>6.setup 的两个注意点</h3><ul><li>setup 执行的时机<ul><li>在 beforeCreate 之前执行一次，this 是 undefined。</li></ul></li><li>setup 的参数<ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h3 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h3><h4 id="1-computed-函数"><a href="#1-computed-函数" class="headerlink" title="1.computed 函数"></a>1.computed 函数</h4><ul><li><p>与 Vue2.x 中 computed 配置功能一致</p></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-watch-函数"><a href="#2-watch-函数" class="headerlink" title="2.watch 函数"></a>2.watch 函数</h4><ul><li><p>与 Vue2.x 中 watch 配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视 reactive 定义的响应式数据时：oldValue 无法正确获取、强制开启了深度监视（deep 配置失效）。</li><li>监视 reactive 定义的响应式数据中某个属性时：deep 配置有效。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  sum,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum, msg], <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum或msg变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  person,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">false</span> &#125;</span><br><span class="line">); <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> person.<span class="property">job</span>,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person的job变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  [<span class="function">() =&gt;</span> person.<span class="property">job</span>, <span class="function">() =&gt;</span> person.<span class="property">name</span>],</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person的job变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> person.<span class="property">job</span>,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person的job变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">); <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-watchEffect-函数"><a href="#3-watchEffect-函数" class="headerlink" title="3.watchEffect 函数"></a>3.watchEffect 函数</h4><ul><li><p>watch 的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect 的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect 有点像 computed：</p><ul><li>但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> x1 = sum.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">const</span> x2 = person.<span class="property">age</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;watchEffect配置的回调执行了&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h3><div class='blog-img'>  <div>    <strong>vue2.x的生命周期</strong>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/12.webp"  style="zoom:33%;width:1200px" />  </div>  <div>    <strong>vue3.0的生命周期</strong>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/13.webp"  style="zoom:33%;width:2500px" />  </div></div><ul><li>Vue3.0 中可以继续使用 Vue2.x 中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0 也提供了 Composition API 形式的生命周期钩子，与 Vue2.x 中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h3 id="9-自定义-hook-函数"><a href="#9-自定义-hook-函数" class="headerlink" title="9.自定义 hook 函数"></a>9.自定义 hook 函数</h3><ul><li><p>什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。</p></li><li><p>类似于 vue2.x 中的 mixin。</p></li><li><p>自定义 hook 的优势: 复用代码, 让 setup 中的逻辑更清楚易懂。</p></li></ul><h3 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h3><ul><li>作用：创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。</li><li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li><li><p>应用: 要将响应式对象中的某个属性单独提供给外部使用时。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><h2 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h2><h3 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h3><ul><li>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h3 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h3><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h3 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h3><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h3 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h3><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; /&gt;</span><br><span class="line">  &lt;h3&gt;&#123;&#123; keyword &#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref, customRef &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Demo&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">    //自定义一个myRef</span><br><span class="line">    function myRef(value, delay) &#123;</span><br><span class="line">      let timer;</span><br><span class="line">      //通过customRef去实现自定义</span><br><span class="line">      return customRef((track, trigger) =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          get() &#123;</span><br><span class="line">            track(); //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">            return value;</span><br><span class="line">          &#125;,</span><br><span class="line">          set(newValue) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = setTimeout(() =&gt; &#123;</span><br><span class="line">              value = newValue;</span><br><span class="line">              trigger(); //告诉Vue去更新界面</span><br><span class="line">            &#125;, delay);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    let keyword = myRef(&quot;hello&quot;, 500); //使用程序员自定义的ref</span><br><span class="line">    return &#123;</span><br><span class="line">      keyword,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h3><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h3><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h2 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h2><h3 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h3><p>使用传统 OptionsAPI 中，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改 。</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/33.image" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/34.image" /></div><h3 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h3><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/35.image" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/36.image" /></div><h2 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h2><h3 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h3><ul><li>在 Vue2 中: 组件必须有一个根标签</li><li>在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h3 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h3><ul><li><p>什么是 Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件 html 结构</strong>移动到指定位置的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h3><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./components/Child.vue&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">    &lt;Suspense&gt;</span><br><span class="line">      &lt;template v-slot:default&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:fallback&gt;</span><br><span class="line">        &lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><h3 id="1-全局-API-的转移"><a href="#1-全局-API-的转移" class="headerlink" title="1.全局 API 的转移"></a>1.全局 API 的转移</h3><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0 中对这些 API 做出了调整：</p><ul><li><p>将全局的 API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><p>| 2.x 全局 API（<code>Vue</code>）    | 3.x 实例 API (<code>app</code>)                        |<br>| ———————————— | —————————————————————- |<br>| Vue.config.xxxx          | app.config.xxxx                             |<br>| Vue.config.productionTip | <strong style="color:#DD5145">移除</strong> |<br>| Vue.component            | app.component                               |<br>| Vue.directive            | app.directive                               |<br>| Vue.mixin                | app.mixin                                   |<br>| Vue.use                  | app.use                                     |<br>| Vue.prototype            | app.config.globalProperties                 |</p></li></ul></li></ul><h3 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h3><ul><li><p>data 选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x 写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Vue3.x 写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode 作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  emits: [&quot;close&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
    
    
    <summary type="html">Vue3知识整理</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="vue" scheme="https://munanchun.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>使用vue-Treeselect更改值无法触发表单校验以及文本框校验问题</title>
    <link href="https://munanchun.github.io/posts/6924b15f.html"/>
    <id>https://munanchun.github.io/posts/6924b15f.html</id>
    <published>2023-11-03T10:00:00.000Z</published>
    <updated>2023-11-03T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>在实现表单功能时碰到的两个问题</em></p><h2 id="vue-Treeselect-更改值无法触发表单校验"><a href="#vue-Treeselect-更改值无法触发表单校验" class="headerlink" title="vue-Treeselect 更改值无法触发表单校验"></a>vue-Treeselect 更改值无法触发表单校验</h2><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/23.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/24.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/25.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/26.webp" /></div><p>在使用<code>vue-Treeselect</code>组件时，表单校验为必填项，但是更改值后，无法立即消除校验规则，只有提交时才能清掉校验规则，<code>trigger</code>属性也设置的为<code>change</code></p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/27.webp" /></div><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>在<code>TreeSeelect</code>组件上<code>@input</code>绑定一个方法<code>validateProcessUser</code>用于在表单中该项值更改时进行校验，<code>formName</code>为表单的<code>ref</code>属性，<code>processUser</code>为该表单字段的 prop 值，这样就能在值更改时消除校验了</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/28.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/29.webp" /></div><h2 id="文本框校验特殊需求"><a href="#文本框校验特殊需求" class="headerlink" title="文本框校验特殊需求"></a>文本框校验特殊需求</h2><blockquote><p>现在有一个文本框，要求输入不能为空，但是可以回车以及开头空两字符之类的操作，并且在校验报红状态下输入内容取消报红，类似下图内容</p></blockquote><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/30.webp" /></div><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>进行自定义校验规则，<code>change</code>为输入框输入内容取消报红，<code>validateMessageWithSpaces</code>方法在提交时触发，清空输入内容两侧空格校验是否为空，在输入时使用<code>trim</code>方法导致无法输入空格和回车</p><div class='blog-img'>    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/31.webp" />    <img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/32.webp" /></div>]]></content>
    
    
    <summary type="html">vue中表单校验的两个刁钻问题</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="vue" scheme="https://munanchun.github.io/tags/vue/"/>
    
    <category term="表单校验" scheme="https://munanchun.github.io/tags/%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>响应式网站设计</title>
    <link href="https://munanchun.github.io/posts/77dceb7c.html"/>
    <id>https://munanchun.github.io/posts/77dceb7c.html</id>
    <published>2023-09-09T16:00:00.000Z</published>
    <updated>2023-09-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整</p><p>描述响应式界面最著名的一句话就是“Content is like water”</p><p>大白话便是“如果将屏幕看作容器，那么内容就像水一样”</p><p>响应式网站常见特点：</p><ul><li>同时适配 PC + 平板 + 手机等</li><li>标签导航在接近手持终端设备时改变为经典的抽屉式导航</li><li>网站的布局会根据视口来调整模块的大小和位置</li></ul><div class='blog-img'>  <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/44.png' /></div><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><p>响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有<code>meta</code>声明<code>viewport</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;</span></span></span><br></pre></td></tr></table></figure><p>属性对应如下：</p><ul><li>width=device-width: 是自适应手机屏幕的尺寸宽度</li><li>maximum-scale:是缩放比例的最大值</li><li>inital-scale:是缩放的初始化</li><li>user-scalable:是用户的可以缩放的操作</li></ul><p>实现响应式布局的方式有如下：</p><ul><li>媒体查询</li><li>百分比</li><li>vw/vh</li><li>rem</li></ul><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p><code>CSS3</code>中的增加了更多的媒体查询，就像<code>if</code>条件表达式一样，我们可以设置不同类型的媒体条件，并根据对应的条件，给相应符合条件的媒体调用相对应的样式表</p><p>使用<code>@Media</code>查询，可以针对不同的媒体类型定义不同的样式，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1920px</span>) &#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当视口在 375px - 600px 之间，设置特定字体大小 18px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen (<span class="attribute">min-width</span>: <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局，比如我们为不同分辨率的屏幕，设置不同的背景图片</p><p>比如给小屏幕手机设置@2x 图，为大屏幕手机设置@3x 图，通过媒体查询就能很方便的实现</p><h3 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h3><p>通过百分比单位 “ % “ 来实现响应式的效果</p><p>比如当浏览器的宽度或者高度发生变化时，通过百分比单位，可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果</p><p><code>height</code>、<code>width</code>属性的百分比依托于父标签的宽高，但是其他盒子属性则不完全依赖父元素：</p><ul><li>子元素的 top/left 和 bottom/right 如果设置百分比，则相对于直接非 static 定位(默认定位)的父元素的高度/宽度</li><li>子元素的 padding 如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的 width，而与父元素的 height 无关。</li><li>子元素的 margin 如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的 width</li><li>border-radius 不一样，如果设置 border-radius 为百分比，则是相对于自身的宽度</li></ul><p>可以看到每个属性都使用百分比，会照成布局的复杂度，所以不建议使用百分比来实现响应式</p><h3 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw/vh"></a>vw/vh</h3><p><code>vw</code>表示相对于视图窗口的宽度，<code>vh</code>表示相对于视图窗口高度。 任意层级元素，在使用<code>vw</code>单位的情况下，<code>1vw</code>都等于视图宽度的百分之一</p><p>与百分比布局很相似，在以前文章提过与<code>%</code>的区别，这里就不再展开述说</p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>在以前也讲到，<code>rem</code>是相对于根元素<code>html</code>的<code>font-size</code>属性，默认情况下浏览器字体大小为<code>16px</code>，此时<code>1rem = 16px</code></p><p>可以利用前面提到的媒体查询，针对不同设备分辨率改变<code>font-size</code>的值，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">414px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">375px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更准确监听设备可视窗口变化，我们可以在<code>css</code>之前插入<code>script</code>标签，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态为根元素设置字体大小</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取屏幕宽度</span></span><br><span class="line">  <span class="keyword">var</span> width = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">  <span class="comment">// 设置根元素字体大小。此时为宽的10等分</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = width / <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首次加载应用，设置一次</span></span><br><span class="line"><span class="title function_">init</span>();</span><br><span class="line"><span class="comment">// 监听手机旋转的事件的时机，重新设置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;orientationchange&quot;</span>, init);</span><br><span class="line"><span class="comment">// 监听手机窗口变化，重新设置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, init);</span><br></pre></td></tr></table></figure><p>无论设备可视窗口如何变化，始终设置<code>rem</code>为<code>width</code>的 1/10，实现了百分比布局</p><p>除此之外，我们还可以利用主流<code>UI</code>框架，如：<code>element ui</code>、<code>antd</code>提供的栅格布局实现响应式</p><p><strong>响应式设计实现通常会从以下几方面思考：</strong></p><ul><li>弹性盒子（包括图片、表格、视频）和媒体查询等技术</li><li>使用百分比布局创建流式布局的弹性 UI，同时使用媒体查询限制元素的尺寸和内容变更范围</li><li>使用相对单位使得内容自适应调节</li><li>选择断点，针对不同断点实现不同布局和内容展示</li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>响应式布局优点可以看到：</p><ul><li>面对不同分辨率设备灵活性强</li><li>能够快捷解决多设备显示适应问题</li></ul><p>缺点：</p><ul><li>仅适用布局、信息、框架并不复杂的部门类型网站</li><li>兼容各种设备工作量大，效率低下</li><li>代码累赘，会出现隐藏无用的元素，加载时间加长</li><li>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li><li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li></ul>]]></content>
    
    
    <summary type="html">如何设计一个响应式网站，要注意什么</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="响应式" scheme="https://munanchun.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    <category term="前端" scheme="https://munanchun.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>用JavaScript创建一个灵活且响应迅速的网页设计</title>
    <link href="https://munanchun.github.io/posts/38e1ff4a.html"/>
    <id>https://munanchun.github.io/posts/38e1ff4a.html</id>
    <published>2023-08-03T16:00:00.000Z</published>
    <updated>2023-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;前段时间写了一个数据可视化大屏的项目，从纯 h5c3+js 的一个页面改成一个 vue3 的小项目，因为是数据可视化大屏这种需要适配更大的屏幕，所以单位应该设置适配从而在大屏上进行显示.</p><h2 id="flexible-js-移动端自适应方案"><a href="#flexible-js-移动端自适应方案" class="headerlink" title="flexible.js 移动端自适应方案"></a>flexible.js 移动端自适应方案</h2><h3 id="一、官方文档："><a href="#一、官方文档：" class="headerlink" title="一、官方文档："></a>一、官方文档：</h3><p>flexible.js 是手淘开发出的一个用来适配移动端的 js 框架。手淘框架的核心原理就是根据制不同的 width 给网页中 html 根节点设置不同的 font-size，然后所有的 px 都用 rem 来代替，这样就实现了不同大小的屏幕都适应相同的样式了。其实它就是一个终端设备适配的解决方案，也就是说它可以让你在不同的终端设备中实现页面适配。</p><p>github 地址：<a href="https://link.jianshu.com/?t=https://github.com/amfe/lib-flexible">https://github.com/amfe/lib-flexible</a><br>官方文档地址：<a href="https://link.jianshu.com/?t=https://github.com/amfe/article/issues/17">https://github.com/amfe/article/issues/17</a></p><h3 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h3><ul><li><strong>引入方式</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.2/??flexible_css.js,flexible.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>单页面应用使用（<code>webpack</code> 构建工具使用）</strong></li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> i -S amfe-flexible</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/amfe-flexible/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">win, lib</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> doc = win.<span class="property">document</span>;</span><br><span class="line">  <span class="keyword">var</span> docEl = doc.<span class="property">documentElement</span>;</span><br><span class="line">  <span class="keyword">var</span> metaEl = doc.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> flexibleEl = doc.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;flexible&quot;]&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> scale = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> tid;</span><br><span class="line">  <span class="keyword">var</span> flexible = lib.<span class="property">flexible</span> || (lib.<span class="property">flexible</span> = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metaEl) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;将根据已有的meta标签来设置缩放比例&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> match = metaEl</span><br><span class="line">      .<span class="title function_">getAttribute</span>(<span class="string">&quot;content&quot;</span>)</span><br><span class="line">      .<span class="title function_">match</span>(<span class="regexp">/initial\-scale=([\d\.]+)/</span>);</span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">      scale = <span class="built_in">parseFloat</span>(match[<span class="number">1</span>]);</span><br><span class="line">      dpr = <span class="built_in">parseInt</span>(<span class="number">1</span> / scale);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flexibleEl) &#123;</span><br><span class="line">    <span class="keyword">var</span> content = flexibleEl.<span class="title function_">getAttribute</span>(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (content) &#123;</span><br><span class="line">      <span class="keyword">var</span> initialDpr = content.<span class="title function_">match</span>(<span class="regexp">/initial\-dpr=([\d\.]+)/</span>);</span><br><span class="line">      <span class="keyword">var</span> maximumDpr = content.<span class="title function_">match</span>(<span class="regexp">/maximum\-dpr=([\d\.]+)/</span>);</span><br><span class="line">      <span class="keyword">if</span> (initialDpr) &#123;</span><br><span class="line">        dpr = <span class="built_in">parseFloat</span>(initialDpr[<span class="number">1</span>]);</span><br><span class="line">        scale = <span class="built_in">parseFloat</span>((<span class="number">1</span> / dpr).<span class="title function_">toFixed</span>(<span class="number">2</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maximumDpr) &#123;</span><br><span class="line">        dpr = <span class="built_in">parseFloat</span>(maximumDpr[<span class="number">1</span>]);</span><br><span class="line">        scale = <span class="built_in">parseFloat</span>((<span class="number">1</span> / dpr).<span class="title function_">toFixed</span>(<span class="number">2</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dpr &amp;&amp; !scale) &#123;</span><br><span class="line">    <span class="keyword">var</span> isAndroid = win.<span class="property">navigator</span>.<span class="property">appVersion</span>.<span class="title function_">match</span>(<span class="regexp">/android/gi</span>);</span><br><span class="line">    <span class="keyword">var</span> isIPhone = win.<span class="property">navigator</span>.<span class="property">appVersion</span>.<span class="title function_">match</span>(<span class="regexp">/iphone/gi</span>);</span><br><span class="line">    <span class="keyword">var</span> devicePixelRatio = win.<span class="property">devicePixelRatio</span>;</span><br><span class="line">    <span class="keyword">if</span> (isIPhone) &#123;</span><br><span class="line">      <span class="comment">// iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案</span></span><br><span class="line">      <span class="keyword">if</span> (devicePixelRatio &gt;= <span class="number">3</span> &amp;&amp; (!dpr || dpr &gt;= <span class="number">3</span>)) &#123;</span><br><span class="line">        dpr = <span class="number">3</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (devicePixelRatio &gt;= <span class="number">2</span> &amp;&amp; (!dpr || dpr &gt;= <span class="number">2</span>)) &#123;</span><br><span class="line">        dpr = <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dpr = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他设备下，仍旧使用1倍的方案</span></span><br><span class="line">      dpr = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    scale = <span class="number">1</span> / dpr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  docEl.<span class="title function_">setAttribute</span>(<span class="string">&quot;data-dpr&quot;</span>, dpr);</span><br><span class="line">  <span class="keyword">if</span> (!metaEl) &#123;</span><br><span class="line">    metaEl = doc.<span class="title function_">createElement</span>(<span class="string">&quot;meta&quot;</span>);</span><br><span class="line">    metaEl.<span class="title function_">setAttribute</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;viewport&quot;</span>);</span><br><span class="line">    metaEl.<span class="title function_">setAttribute</span>(</span><br><span class="line">      <span class="string">&quot;content&quot;</span>,</span><br><span class="line">      <span class="string">&quot;initial-scale=&quot;</span> +</span><br><span class="line">        scale +</span><br><span class="line">        <span class="string">&quot;, maximum-scale=&quot;</span> +</span><br><span class="line">        scale +</span><br><span class="line">        <span class="string">&quot;, minimum-scale=&quot;</span> +</span><br><span class="line">        scale +</span><br><span class="line">        <span class="string">&quot;, user-scalable=no&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (docEl.<span class="property">firstElementChild</span>) &#123;</span><br><span class="line">      docEl.<span class="property">firstElementChild</span>.<span class="title function_">appendChild</span>(metaEl);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> wrap = doc.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      wrap.<span class="title function_">appendChild</span>(metaEl);</span><br><span class="line">      doc.<span class="title function_">write</span>(wrap.<span class="property">innerHTML</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">refreshRem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> width = docEl.<span class="title function_">getBoundingClientRect</span>().<span class="property">width</span>;</span><br><span class="line">    <span class="keyword">if</span> (width / dpr &gt; <span class="number">540</span>) &#123;</span><br><span class="line">      width = <span class="number">540</span> * dpr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rem = width / <span class="number">10</span>;</span><br><span class="line">    docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    flexible.<span class="property">rem</span> = win.<span class="property">rem</span> = rem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  win.<span class="title function_">addEventListener</span>(</span><br><span class="line">    <span class="string">&quot;resize&quot;</span>,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">      tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">  win.<span class="title function_">addEventListener</span>(</span><br><span class="line">    <span class="string">&quot;pageshow&quot;</span>,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.<span class="property">persisted</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(tid);</span><br><span class="line">        tid = <span class="built_in">setTimeout</span>(refreshRem, <span class="number">300</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (doc.<span class="property">readyState</span> === <span class="string">&quot;complete&quot;</span>) &#123;</span><br><span class="line">    doc.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="number">12</span> * dpr + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doc.<span class="title function_">addEventListener</span>(</span><br><span class="line">      <span class="string">&quot;DOMContentLoaded&quot;</span>,</span><br><span class="line">      <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        doc.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="number">12</span> * dpr + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">refreshRem</span>();</span><br><span class="line"></span><br><span class="line">  flexible.<span class="property">dpr</span> = win.<span class="property">dpr</span> = dpr;</span><br><span class="line">  flexible.<span class="property">refreshRem</span> = refreshRem;</span><br><span class="line">  flexible.<span class="property">rem2px</span> = <span class="keyword">function</span> (<span class="params">d</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">parseFloat</span>(d) * <span class="variable language_">this</span>.<span class="property">rem</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> d === <span class="string">&quot;string&quot;</span> &amp;&amp; d.<span class="title function_">match</span>(<span class="regexp">/rem$/</span>)) &#123;</span><br><span class="line">      val += <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;;</span><br><span class="line">  flexible.<span class="property">px2rem</span> = <span class="keyword">function</span> (<span class="params">d</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">parseFloat</span>(d) / <span class="variable language_">this</span>.<span class="property">rem</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> d === <span class="string">&quot;string&quot;</span> &amp;&amp; d.<span class="title function_">match</span>(<span class="regexp">/px$/</span>)) &#123;</span><br><span class="line">      val += <span class="string">&quot;rem&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>, <span class="variable language_">window</span>[<span class="string">&quot;lib&quot;</span>] || (<span class="variable language_">window</span>[<span class="string">&quot;lib&quot;</span>] = &#123;&#125;));</span><br></pre></td></tr></table></figure><h2 id="简化方案"><a href="#简化方案" class="headerlink" title="简化方案"></a>简化方案</h2><p>为了简化移动端自适应的实现，我提供了一种更简单的方案。以下是该方案的具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">flexible</span>(<span class="params"><span class="variable language_">window</span>, <span class="variable language_">document</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取整个html文档根元素</span></span><br><span class="line">  <span class="keyword">var</span> docEl = <span class="variable language_">document</span>.<span class="property">documentElement</span>;</span><br><span class="line">  <span class="comment">// 用于获取设备的像素密度(dpr)，如果设备支持获取DPR，则获取实际DPR值，否则默认设置为1</span></span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span> || <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于根据设备的DPR动态调整&lt;body&gt;元素的字体大小。它将&lt;body&gt;元素的字体大小设置为 12乘以 DPR后的值，以并像素（px）为单位</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setBodyFontSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="number">12</span> * dpr + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, setBodyFontSize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setBodyFontSize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于根据页面的宽度动态调整&lt;html&gt;元素的字体大小（rem单位）。它将页面的宽度除以24后作为rem的值，并以像素（px）为单位设置给&lt;html&gt;元素的字体大小。</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setRemUnit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> rem = docEl.<span class="property">clientWidth</span> / <span class="number">24</span>;</span><br><span class="line">    docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setRemUnit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听窗口的resize事件，当页面尺寸改变时，重新调用setRemUnit函数来更新&lt;html&gt;元素的字体大小</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, setRemUnit);</span><br><span class="line">  <span class="comment">// 监听窗口的pageshow事件，这个事件在页面被加载时触发，</span></span><br><span class="line">  <span class="comment">// 包括从缓存中加载。如果在缓存中加载，即e.persisted为true，则重新调用setRemUnit函数来更新&lt;html&gt;元素的字体大小</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pageshow&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">persisted</span>) &#123;</span><br><span class="line">      <span class="title function_">setRemUnit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于检测是否支持0.5像素的边框。</span></span><br><span class="line">  <span class="comment">// 在设备的DPR大于等于2的情况下，创建一个临时的测试元素（&lt;div&gt;），设置其边框样式为0.5像素的透明边框，并添加到文档中。</span></span><br><span class="line">  <span class="comment">// 然后检查这个元素的高度是否为1像素，如果是，则说明设备支持0.5像素的边框，</span></span><br><span class="line">  <span class="comment">// 此时会在&lt;html&gt;元素上添加一个名为&quot;hairlines&quot;的类，以便在CSS中可以应用特定样式来修复一些在高DPR设备上边框显示不清晰的问题</span></span><br><span class="line">  <span class="keyword">if</span> (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fakeBody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;body&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> testElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    testElement.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&quot;.5px solid transparent&quot;</span>;</span><br><span class="line">    fakeBody.<span class="title function_">appendChild</span>(testElement);</span><br><span class="line">    docEl.<span class="title function_">appendChild</span>(fakeBody);</span><br><span class="line">    <span class="keyword">if</span> (testElement.<span class="property">offsetHeight</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      docEl.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hairline&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.<span class="title function_">removeChild</span>(fakeBody);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>, <span class="variable language_">document</span>);</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>项目中使用的话，可以放在<code>src/utils/flexible.js</code>文件中，在<code>main.js</code>文件中直接引入即可使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./utils/flexible&quot;</span>;</span><br></pre></td></tr></table></figure><p>此时在 css 样式中，可以用 rem 单位代替 px，其中项目页面是以 1920px 为宽度，适配之后 1rem = 80px，示例如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.475rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在使用此简化方案时，请注意以下几点：</p><ol><li><strong>设置页面宽度：</strong> 我们默认将页面宽度设置为 <code>1920px</code> 作为基准进行适配，你可以根据实际情况调整该值。</li><li><strong>兼容性考虑：</strong> 该方案在大多数现代浏览器和设备上都能良好运行，但仍需进行充分测试以确保在不同环境下的兼容性。</li><li><strong>适用场景：</strong> 此方案适用于大多数移动端项目，特别是对于需要快速实现自适应的小型项目来说，是一个不错的选择。</li></ol><h3 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h3><p>另外，推荐一个 VSCode 插件可以帮助你更方便地进行 px 到 rem 的单位转换，提高开发效率。尤其在移动端适配过程中，能够帮助你快速计算合适的 rem 值。</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/14.webp' /></div><p>需要进行扩展设置，设置好相应的宽度，就可以进行快速转换了</p><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/15.webp' /></div><div class='blog-img'> <img src='https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/16.webp' /></div>]]></content>
    
    
    <summary type="html">在不同设备上以统一的视觉效果展示数据可视化大屏</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="数据可视化" scheme="https://munanchun.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="适配" scheme="https://munanchun.github.io/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Vue2</title>
    <link href="https://munanchun.github.io/posts/f8e09374.html"/>
    <id>https://munanchun.github.io/posts/f8e09374.html</id>
    <published>2023-04-14T21:20:00.000Z</published>
    <updated>2023-04-14T21:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><hr><h3 id="Vue-渐进式理解"><a href="#Vue-渐进式理解" class="headerlink" title="Vue 渐进式理解"></a><a href="https://blog.csdn.net/wangzunkuan/article/details/80729683">Vue 渐进式理解</a></h3><h3 id="Vue-render-函数"><a href="#Vue-render-函数" class="headerlink" title="Vue render 函数"></a><a href="https://www.jianshu.com/p/7508d2a114d3">Vue render 函数</a></h3><h3 id="vue-diff-算法"><a href="#vue-diff-算法" class="headerlink" title="vue diff 算法"></a><a href="https://www.bilibili.com/video/BV1JR4y1R7Ln/?spm_id_from=333.788&amp;vd_source=e754d95b996bf636e1256b88397221dd">vue diff 算法</a></h3><h2 id="Vue-核心"><a href="#Vue-核心" class="headerlink" title="Vue 核心"></a>Vue 核心</h2><h3 id="初识-Vue"><a href="#初识-Vue" class="headerlink" title="初识 Vue"></a><strong>初识 Vue</strong></h3><p>1.想让 Vue 工作,就必须创建一个 Vue 实例,且要传入一个配置对象;</p><p>2.root 容器里的代码依然符合 html 规范，只不过混入了一些特殊的 Vue 语法;</p><p>3.root 容器里的代码被称为【Vue 模板】;</p><p>4.Vue 实例和容器是一一对应的;</p><p>5.真实开发中只有一个 Vue 实例，并且会配合着组件一起使用;</p><p>6.<code>&#123;&#123;xxx&#125;&#125;</code>中的 xxx 要写 js 表达式，且 xxx 可以自动读取到 data 中的所有属性;</p><p>7.一旦 data 中的数据发生改变，那么页面中用到该数据的地方也会自动更新;</p><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a><strong>模板语法</strong></h3><p>1.插值语法:<br>功能:用于解析标签体内容。<br>写法:<code>&#123;&#123;xxx&#125;&#125;</code>，xxx 是 js 表达式，且可以直接读取到 data 中的所有属性。</p><p>2.指令语涛<br>功能:用于解析标签（包括:际签属性、标签体内容、绑定事件…..)<br>举例: v-bind:href=”xxx”或简写为:href=”xxx”，xxx 同样要写 js 表达式,<br>且可以直接读取到 data 中的所有属性。<br>备注: Vue 中有很多的指令，且形式都是:v-????，此处拿 v-bind 举个例子。</p><hr><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>单向数据绑定 (v-bind)</p><ol><li><p>语法：v-bind:href =”xxx” 或简写为 :href</p></li><li><p>特点：数据只能从 data 流向页面</p></li></ol><p>双向数据绑定 (v-model)</p><ol><li>语法：v-mode:value=”xxx” 或简写为 v-model=”xxx”</li><li>特点：数据不仅能从 data 流向页面，还能从页面流向 data</li></ol><p><strong>备注</strong>:</p><ol><li><p>双向绑定一般都应用在表单类元素上(如: input、select 等)</p></li><li><p>v-model :value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值。</p></li></ol><hr><h3 id="el-与-data-的两种写法"><a href="#el-与-data-的两种写法" class="headerlink" title="el 与 data 的两种写法"></a>el 与 data 的两种写法</h3><p>1.el 有 2 种写法<br>(1). new Vue 时候配置 el 属性。<br>(2). 先创建 Vue 实例，随后再通过 vm.$mount( ‘#root’)指定 el 的值。<br>2.data 有 2 种写法<br>(1).对象式 (2).函数式</p><p><strong>3.一个重要的原则:</strong><br>由 Vue 管理的函数，一定不要写箭头函数，一旦写了箭头函数，this 就不再是 Vue 实例了。</p><hr><h3 id="MVVM-模型"><a href="#MVVM-模型" class="headerlink" title="MVVM 模型"></a>MVVM 模型</h3><ol><li>M：模型(Model) ：对应 data 中的数据</li><li>V：视图(View) ：模板</li><li>VM：视图模型(ViewModel) ： Vue 实例对象</li></ol><p><img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/3.webp"  style="zoom:67%;" /></p><p>data 中所有的属性,最后都出现在了 vm 身上。<br>vm 身上所有的属性及 Vue 原型上所有属性，在 Vue 模板中都可以直接使用。</p><p><strong>MVVM 的核心</strong>是 ViewModel 层面 他就像是一个中转站 负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上的与视图进行双向绑定 向下与 Model 层通过接口请求请求进行数据交互，起承上启下作用。View 层展现的不是 Model 的数据，而是 ViewModel 层的数 由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的最重要一环。</p><h4 id="Object-defineProperty-方法"><a href="#Object-defineProperty-方法" class="headerlink" title="Object.defineProperty 方法"></a>Object.defineProperty 方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">18</span></span><br><span class="line">    <span class="keyword">let</span> person = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">        <span class="comment">// value: 18,</span></span><br><span class="line">        <span class="comment">// enumerable: true,   //控制属性是否可以枚举，默认值是false</span></span><br><span class="line">        <span class="comment">// writable: true,     //控制属性是否可以被修改，默认值是false</span></span><br><span class="line">        <span class="comment">// configurable: true   //控制属性是否可以被删除，默认值是false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值</span></span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当有人修改person的age属性时，set函数(setter)就会被调用，且会受到修改的具体值</span></span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            number = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="vue-双向绑定原理及实现"><a href="#vue-双向绑定原理及实现" class="headerlink" title="vue 双向绑定原理及实现*"></a><a href="https://www.cnblogs.com/canfoo/p/6891868.html">vue 双向绑定原理及实现</a>*</h4><hr><h3 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h3><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=13&amp;spm_id_from=pageDriver&amp;vd_source=e754d95b996bf636e1256b88397221dd">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=13&amp;spm_id_from=pageDriver&amp;vd_source=e754d95b996bf636e1256b88397221dd</a></p><p><img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/4.webp"  style="zoom: 50%;" /></p><p>1.Vue 中的数据代理:<br>通过 vm 对象来代理 data 对象中属性的操作(读/写）</p><p>2.Vue 中数据代理的好处:<br>更加方便的操作 data 中的数据</p><p>3.基本原理:<br>通过 object.defineProperty()把 data 对象中所有属性添加到 vm 上.为每一个添加到 vm 上的属性，都指定一个 getter/setter。<br>在 getter/setter 内部去操作（读/写)data 中对应的属性。</p><hr><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h4 id="事件的基本使用"><a href="#事件的基本使用" class="headerlink" title="事件的基本使用"></a>事件的基本使用</h4><p>1.使用 v-on:xxx 或@xxx 绑定事件，其中 xxx 是事件名;</p><p>2.事件的回调需要配置在 methods 对象中，最终会在 vm 上;</p><p>3.methods 中配置的函数，不要用箭头函数! 否则 this 就不是 vm 了;</p><p>4.methods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或 组件实例对象;</p><p>5.@click=”demo”和@click=”demo($event)”效果一致，但后者可以传参;</p><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>1.prevent: 阻止默认事件（常用）;</p><p>2.stop: 阻止事件冒泡（常用）;</p><p>3.once: 事件只触发一次（常用）;</p><p>4.capture: 使用事件的捕获模式;</p><p>5.self: 只有 event.target 是当前操作的元素时才触发事件;</p><p>6.passive: 事件的默认行为立即执行，无需等待事件回调执行完毕;</p><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>1.Vue 中常用的按键别名:</p><ul><li><p>回车=&gt; enter</p></li><li><p>删除=&gt; delete(捕获“删除”和“退格”键)</p></li><li>退出=&gt; esc</li><li>空格=&gt; space</li><li>换行=&gt; tab（特殊，必须配合 keydown 使用）</li><li>上=&gt; up</li><li>下=&gt; down</li><li>左=&gt; left</li><li><p>右=&gt; right</p><p>2.Vue 未提供别名的按健，可以使用按健原始的 key 值去绑定，但注意要转为 kebab-case(短横线命名)</p><p>3.系统修饰键（用法特殊）:ctrl、alt、 shift、meta</p></li></ul><p>​ (1).配合 keyup 使用:按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p><p>​ (2).配合 keydown 使用:正常触发事件。</p><p>4.也可以使用 keyCode 去指定具体的按键（不推荐)</p><p>5.Vue.config. keyCodes.自定义键名=健码，可以去定制按键别名</p><hr><h3 id="计算属性与监视"><a href="#计算属性与监视" class="headerlink" title="计算属性与监视"></a>计算属性与监视</h3><p>1.定义:要用的属性不存在，要通过已有属性计算得来。</p><p>2.原理:底层借助了 object.defineproperty 方法提供的 getter 和 setter.</p><p>3.get 函数什么时候执行?<br>(1).初次读取时会执行一次。<br>(2).当依赖的数据发生改变时会被再次调用。</p><p>4.优势:与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便。</p><p>5.备注:<br>(1).计算属性最终会出现在 vm 上，直接读取使用即可。<br>(2).如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变。</p><h4 id="监视属性-watch"><a href="#监视属性-watch" class="headerlink" title="监视属性 watch"></a>监视属性 watch</h4><p>1.当被监视的属性变化时,回调函数自动调用，进行相关操作</p><p>2.监视的属性必须存在,才能进行监视 ！！！</p><p>3.监视的两种写法:</p><p>​ (1).new Vue 时传入 watch 配置</p><p>​ (2).通过 vm.$watch 监视</p><h4 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视"></a>深度监视</h4><p>​ (1).vue 中的 watch 默认不监测对象内部值的改变（一层）。</p><p>​ (2).配置 deep:true 可以监测对象内部值改变（多层）。</p><p>备注:</p><p>​ (1).Vue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以！</p><p>​ (2).使用 watch 时根据数据的具体结构，决定是否采用深度监视。</p><h4 id="computed-和-watch-之间的区别"><a href="#computed-和-watch-之间的区别" class="headerlink" title="computed 和 watch 之间的区别"></a>computed 和 watch 之间的区别</h4><p>​ 1.computed 能完成的功能,watch 都可以完成。<br>​ 2.watch 能完成的功能，computed 不一定能完成，例如: watch 可以进行异步操作。</p><p>两个重要的小原则:</p><p>​ 1.所被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或 组件实例对象</p><p>​ 2.所有不被 Vue 所管理的函数（定时器的回调函数、ajax 的回调函数等、Promise 的回调函数)，最好写成箭头函数,这样 this 的指向才是 vm 或组件实例对象。</p><hr><h3 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a>绑定样式</h3><h4 id="class-样式"><a href="#class-样式" class="headerlink" title="class 样式"></a>class 样式</h4><p>写法：class=” xxx” xxx 可以是字符串、对象、数组。<br>字符串写法适用于：类名不确定,要动态获取。<br>对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。<br>数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p><h4 id="style-样式"><a href="#style-样式" class="headerlink" title="style 样式"></a>style 样式</h4><p>:style=”{fontsize: xxx}” 其中 xxx 是动态值。</p><p>:style=”[a,b]” 其中 a、b 是样式对象。</p><hr><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><p>写法:<br>(1).v-if=”表达式”</p><p>​(2).v-else-if=”表达式”</p><p>​ (3).v-else=”表达式”</p><p>适用于: 切换频率较低的场景。</p><p>特点: 不展示的 DOM 元素直接被移除。</p><p>注意: v-if 可以和: v-else-if、v-else 一起使用，但要求结构不能被“打断”。</p><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>写法: v-show=”表达式”</p><p>适用于: 切换频率较高的场景。</p><p>特点: 不展示的 DOM 元素未被移除,仅仅是使用样式隐藏掉</p><p><strong>备注</strong>:使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">&quot;???&quot;</span>&gt;???&lt;/template&gt;</span><br><span class="line"><span class="comment">//template 母版，最终不会渲染到页面上，页面上只会出现中间的内容，template配合v-if使用</span></span><br></pre></td></tr></table></figure><hr><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="v-for-指令"><a href="#v-for-指令" class="headerlink" title="v-for 指令"></a>v-for 指令</h4><p>1.用于展示列表数据 2.语法: v-for=” (item,index) in xxx” :key=”yyy” 3.可遍历: 数组、对象、字符串（用的很少）、指定次数（用的很少)</p><h4 id="key-作用与原理"><a href="#key-作用与原理" class="headerlink" title="key 作用与原理"></a>key 作用与原理</h4><p>面试题: react、vue 中的 key 有什么作用?（key 的内部原理)</p><ol><li><p>虚拟 DOM 中 key 的作用:<br>key 是虚拟 DOM 对象的标识，当状态中的数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】,随后 Vue 进行【新虚拟 DOM】与【旧虚拟 DOM】的差异比较，比较规则如下:</p></li><li><p>对比规则:<br>(1).旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key:<br>若虚拟 DOM 中内容没变，直接使用之前的真实 DOM !<br>若虚拟 DOM 中内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM。<br>(2).旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key<br>创建新的真实 DOM,随后渲染到到页面。</p></li><li><p>用 index 作为 key 可能会引发的问题:</p><ol><li>若对数据进行: 逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实 DOM 更新 ==&gt; 界面效果没问题，但效率低。</li><li>如果结构中还包含输入类的 DOM: 会产生错误 DOM 更新 ==&gt; 界面有问题。</li></ol></li><li><p>开发中如何选择 key? :</p><ol><li>最好使用每条数据的唯一标识作为 key，比如 id、手机号、身份证号、学号等唯一值。</li><li>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示,使用 index 作为 key 是没有问题的。</li></ol></li></ol><hr><h3 id="监测数据"><a href="#监测数据" class="headerlink" title="监测数据"></a>监测数据</h3><p>1.vue 会监视 data 中所有层次的数据。</p><p>2.如何监测对象中的数据?</p><p>​ 通过 setter 实现监视,且要在 new Vue 时就传入要监测的数据。</p><p>​ (1).对象中后追加的属性，Vue 默认不做响应式处理</p><p>​ (2).如需给后添加的属性做响应式，请使用如下 API:</p><p>​ vue.set(target, propertyName/index, value）或</p><p>​ vm.$set(target, propertyName/index, value)</p><p>3.如何监测数组中的数据?</p><p>​ 通过包裹数组更新元素的方法实现,本质就是做了两件事:</p><p>​ (1).调用原生对应的方法对数组进行更新。</p><p>​ (2).重新解析模板,进而更新页面。</p><p>4.在 Vue 修改数组中的某个元素一定要用如下方法:</p><p>​ 1.使用这些 API: push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><p>​ 2.Vue.set() 或 vm.$set()</p><p><strong>特别注意</strong>: Vue.set(）和 vm.$set()不能给 vm 或 vm 的根数据对象添加属性！！！</p><hr><h3 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h3><p>若:<code>&lt;input type=&quot;text&quot;/&gt;</code>, 则 v-model 收集的是 value 值。用户输入的就是 value 值。</p><p>若:<code>&lt;input type=&quot;radio&quot;/&gt;</code>，则 v-model 收集的是 value 值，且要给标签配置 value 值。</p><p>若:<code>&lt;input type=&quot;checkbox&quot; /&gt;</code></p><p>​ 1.没有配置 input 的 value 属性，那么收集的就是 checked(勾选 or 未勾选，是布尔值)</p><p>​ 2.配置 input 的 value 属性:</p><p>​ (1) v-model 的初始值是非数组，那么收集的就是 checked（勾选 or 未勾选，是布尔值)</p><p>​ (2) v-model 的初始值是数组，那么收集的的就是 value 组成的数组</p><p><strong>备注</strong>: v-model 的三个修饰符:</p><p>​ lazy: 失去焦点再收集数据</p><p>​ number: 输入字符串转为有效的数字</p><p>​ ​trim: 输入首尾空格过滤</p><h3 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h3><p>v-bind : 单向绑定解析表达式，可简写为:xxx</p><p>v-model : 双向数据绑定</p><p>v-for : 遍历数组/对象/字符串</p><p>v-on : 绑定事件监听，可简写为@</p><p>v-if : 条件渲染(动态控制节点是否存在)</p><p>v-else : 条件渲染（动态控制节点是否存在)</p><p>v-show : 条件渲染(动态控制节点是否展示)</p><p><strong>v-text 指令</strong>:</p><p>1.作用:向其所在的节点中渲染文本内容。</p><p>2.与插值语法的区别:v-text 会替换掉节点中的内容，则不会。</p><p><strong>v-html 指令</strong>:</p><p>1.作用:向指定节点中渲染包含 html 结构的内容。</p><p>2.与插值语法的区别:</p><p>​ (1).v-html 会替换掉节点中所有的内容，则不会。</p><p>​ (2).v-html 可以识别 html 结构。</p><p>3.严重注意: v-html 有安全性问题！！！</p><p>(1).在网站上动态渲染任意 HTML 是非常危险的，容易导致 XSS 攻击。</p><p>(2).一定要在可信的内容上使用 v-html，永不要用在用户提交的内容上!</p><p><strong>v-cloak 指令</strong>(没有值):</p><p>1.本质是一个特殊属性。Vue 实例创建完毕并按管容器后，会剧掉 v-cloak 属性。</p><p>2.使用 css 配合 v-cloak 可以解决网速慢时页面展示出  的问题。</p><p><strong>v-once 指令</strong>:</p><p>1.v-once 所在节点在初次动态演染后,就视为静态内容了。</p><p>2.以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能。</p><p><strong>v-pre 指令</strong>:</p><p>1.跳过其所在节点的编译过程</p><p>2.可利用它跳过:没有使用指令语法、没有使用插值语法的节点，会加快编译。</p><hr><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/5.webp" style="zoom: 80%;" /></p><hr><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>1.又名: 生命周期回调函数、生命周期函数、生命周期钩子。</p><p>2.是什么: Vue 在关键时刻帮我们调用的一些特殊名称的函数。</p><p>3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p><p>4.生命周期函数中的 this 指向是 vm 或 组件实例对象。</p><p><img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/6.webp" alt="生命周期" style="zoom: 20%;" /></p><p>常用的生命周期钩子:</p><p>1.<strong>mounte</strong>发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</p><p>2.<strong>beforeDestroy</strong>: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p><p>关于销毁 Vue 实例</p><p>1.销毁后借助 Vue 开发者工具看不到任何信息。</p><p>2.销毁后自定义事件会失效，但原生 DOM 事件依然有效。</p><p>3.一般不会再 beforeDestroy 操作数据，因为即便操作数据，也不会再触发更新流程了。</p><h2 id="Vue-组件化编程"><a href="#Vue-组件化编程" class="headerlink" title="Vue 组件化编程"></a>Vue 组件化编程</h2><p>Vue 中使用组件的三大步骤:</p><p>​ 1. 定义组件(创建组件）</p><p>​ 2. 注册组件</p><p>​ 3. 使用组件(写组件标签)</p><p>一、如何定义一个组件?</p><p>​ 使用 Vue.extend(options)创建，其中 options 和 new Vue(options)时传入的那个 options 几乎一样，但也有点区别：</p><p>​ 区别如下:</p><p>​ 1.el 不要写，为什么?—最终所有的组件都要经过一个 vm 的管理，由 vm 中的 el 决定服务哪个容器。</p><p>​ 2.data 必须写成函数，为什么?——避免组件被复用时，数据存在引用关系。</p><p>​ <strong>备注</strong>: 使用 template 可以配置组件结构。</p><p>二、如何注册组件?</p><p>1.局部注册: 靠 new Vue 的时候传入 components 选项</p><p>2.全局注册: 靠 Vue.component(‘组件名’,组件)</p><p>三、编写组件标签:<br><code>&lt;school&gt;&lt;/school&gt;</code></p><h3 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h3><p>几个注意点:</p><p>1.关于组件名:<br>一个单词组成:</p><p>​ 第一种写法(首字母小写): school</p><p>​ 第二种写法(首字母大写): School</p><p>​ 多个单词组成:</p><p>​ 第一种写法(kebab-case 命名):my-school</p><p>​ 第二种写法(Camelcase 命名):MySchool（需要 Vue 脚手架支持)</p><p>​ <strong>备注:</strong><br>​ (1).组件名尽可能回避 HTML 中已有的元素名称，例如: h2、H2 都不行。</p><p>​ (2).可以使用 name 配置项指定组件在开发者工具中呈现的名字-</p><p>2.关于组件标签:</p><p>​ 第一种写法:<code>&lt;school&gt;&lt;/school&gt;</code></p><p>​ 第二种写法: <code>&lt;school/&gt;</code></p><p>​ 备注:不用使用脚手架时,<code>&lt;school/&gt;</code>会导致后续组件不能渲染。</p><p>3.一个简写方式:</p><p>​ const school = Vue.extend(options）可简写为: const school = options</p><h4 id="VueComponent"><a href="#VueComponent" class="headerlink" title="VueComponent"></a>VueComponent</h4><ol><li><p>school 组件本质是一个名为 VueComponent 的构造函数，且不是程序员定义的，是 Vue.extend 生成的.</p></li><li><p>我们只需要写<code>&lt;school/&gt;</code>或<code>&lt;school&gt;&lt;/school&gt;</code>，Vue 解析时会帮我们创建 school 组件的实例对象，即 vue 帮我们执行的</p><p>new VueComponent(options)</p></li><li><p>特别注意:每次调用 Vue.extend，返回的都是一个全新的 VueComponent ！！！</p></li><li><p>关于 this 指向:</p><p>(1).组件配置中:</p><p>​ data 函数、methods 中的函数、watch 中的函数、computed 中的函数它们的 this 均是【VueComponent 实例对象】</p><p>(2).new Vue() 配置中:</p><p>​ data 函数、methods 中的函数、watch 中的函数、computed 中的函数它们的 this 均是【Vue 实例对象】.</p></li><li><p>VueComponent 的实例对象，以后简称 vc（也可称之为:组件实例对象）。</p><p>Vue 的实例对象,以后简称 vm.</p></li></ol><hr><h4 id="内置关系"><a href="#内置关系" class="headerlink" title="*内置关系"></a>*内置关系</h4><p>一个重要的内置关系:</p><p>​ <code>VueComponent.prototype.__proto__ === Vue.prototype</code></p><p>为什么要有这个关系:</p><p>​ 让组件实例对象(vc）可以访问到 Vue 原型上的属性、方法。</p><blockquote><p><strong>实例的隐式原型属性永远指向自己缔造者的原型对象。</strong></p></blockquote><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH/?p=60">单文件组件</a></p><h2 id="使用-Vue-脚手架"><a href="#使用-Vue-脚手架" class="headerlink" title="使用 Vue 脚手架"></a>使用 Vue 脚手架</h2><h3 id="初始化脚手架"><a href="#初始化脚手架" class="headerlink" title="初始化脚手架"></a>初始化脚手架</h3><p><strong>创建脚手架</strong></p><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=61&amp;vd_source=e754d95b996bf636e1256b88397221dd">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=61&amp;vd_source=e754d95b996bf636e1256b88397221dd</a></p><h4 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">├── public</span><br><span class="line">│ ├── favicon<span class="selector-class">.ico</span>: 页签图标</span><br><span class="line">│ └── index<span class="selector-class">.html</span>: 主页面</span><br><span class="line">├── <span class="attribute">src</span></span><br><span class="line">│ ├── assets: 存放静态资源</span><br><span class="line">│ │ └── logo<span class="selector-class">.png</span></span><br><span class="line">│ │── component: 存放组件</span><br><span class="line">│ │ └── HelloWorld<span class="selector-class">.vue</span></span><br><span class="line">│ │── App<span class="selector-class">.vue</span>: 汇总所有组件</span><br><span class="line">│ │── <span class="selector-tag">main</span><span class="selector-class">.js</span>: 入口文件</span><br><span class="line">├── <span class="selector-class">.gitignore</span>: git 版本管制忽略的配置</span><br><span class="line">├── babel<span class="selector-class">.config</span><span class="selector-class">.js</span>: babel 的配置文件</span><br><span class="line">├── package<span class="selector-class">.json</span>: 应用包配置文件</span><br><span class="line">├── README<span class="selector-class">.md</span>: 应用描述文件</span><br><span class="line">├── package-lock.json：包版本控制文件</span><br></pre></td></tr></table></figure><h4 id="关于不同版本的-Vue"><a href="#关于不同版本的-Vue" class="headerlink" title="关于不同版本的 Vue:"></a>关于不同版本的 Vue:</h4><p>1.vue.js vue.runtime.xxx.js 的区别:</p><p>​ (1).vue.js 是完整版的 Vue，包含: 核心功能+模板解析器。<br>​ (2).vue.runtime.xxx,js 是运行版的 Vue， 只包含: 核心功能; 没有模板解析器。</p><p>2.因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容。</p><h4 id="vue-config-js-配置文件"><a href="#vue-config-js-配置文件" class="headerlink" title="vue.config.js 配置文件"></a>vue.config.js 配置文件</h4><p>使用<code>vue inspect &gt; output.js</code>可以查看到 Vue 脚手架的默认配置。</p><p>使用 vue.config.js 可以对脚手架进行个性化定制，详情见: <a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></p><h3 id="ref-与-props"><a href="#ref-与-props" class="headerlink" title="ref 与 props"></a>ref 与 props</h3><h4 id="ref-属性"><a href="#ref-属性" class="headerlink" title="ref 属性"></a>ref 属性</h4><p>1.被用来给元素或子组件注册引用信息（id 的替代者)</p><p>2.应用在 htm1 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象(vc)</p><p>3.使用方式:</p><p>​ 打标识: <code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code>或<code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></p><p>​ 获取: this.$refs.xxx</p><h4 id="配置项-props"><a href="#配置项-props" class="headerlink" title="配置项 props"></a>配置项 props</h4><p><img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/7.webp" style="zoom: 80%;" /></p><h3 id="父子组件间的三种通信方式"><a href="#父子组件间的三种通信方式" class="headerlink" title="父子组件间的三种通信方式*"></a>父子组件间的三种通信方式*</h3><h4 id="通过-props-实现通信"><a href="#通过-props-实现通信" class="headerlink" title="通过 props 实现通信"></a>通过 props 实现通信</h4><p>子组件的 props 选项能够接收来自父组件的数据。props 是单项绑定的</p><h5 id="props-静态传递"><a href="#props-静态传递" class="headerlink" title="props 静态传递"></a>props 静态传递</h5><p>子组件通过 props 选项来声明一个自定义的属性，然后父组件就可以再嵌套标签的时候，通过这个属性往子组件传递数据了！</p><p><strong>father_props.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">message</span>=<span class="string">&quot;我是子组件一！&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span>  <span class="comment">&lt;!-- 通过自定义属性传递数据 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;../components/child_props.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Child</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>child_props.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&#x27;message&#x27;</span>] <span class="comment">// 声明一个自定义的属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><hr><h5 id="props-动态传递"><a href="#props-动态传递" class="headerlink" title="props 动态传递"></a>props 动态传递</h5><p>更多的时候我们需要传送一个动态的数据。这时候就可以用==v-bind(:)==实现。通过 v-bind 绑定 props 的自定义的属性，传递过去的就不是静态的字符串了，它可以是一个表达式，布尔值，对象等等任何类型的值</p><p><strong>father_props.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">message</span>=<span class="string">&quot;我是子组件一！&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:message</span>=<span class="string">&quot;a+b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 用一个变量进行动态赋值 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:message</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;../components/child_props.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Child</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">a</span>: <span class="string">&#x27;我是子组件二！&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">b</span>: <span class="number">41</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">msg</span>: <span class="string">&#x27;我是子组件三！&#x27;</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><hr><p><strong>child_props.vue 子组件不变</strong></p><h4 id="通过-ref-实现通信"><a href="#通过-ref-实现通信" class="headerlink" title="通过$ref 实现通信"></a>通过$ref 实现通信</h4><p>对于 ref 官方的解释是：ref 是被用来给元素或子组件注册引用信息的。引用信息将会注册在父组件的$refs 对象上。</p><p>props 是父组件给子组件信息，那么，$ref 就是子组件给父组件信息。</p><p>简单来说，父组件可以通过$ref 来调用子组件的信息，包括 data 和 methods</p><p><strong>father_ref.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;../components/child_ref.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Child</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mounted</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">msg</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">msg</span>.<span class="title function_">getMessage</span>(<span class="string">&#x27;我是子组件一！&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>child_ref.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    getMessage (m) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">message</span> = m</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="props-和-ref-的对比"><a href="#props-和-ref-的对比" class="headerlink" title="props 和$ref 的对比"></a>props 和$ref 的对比</h4><p>1.前者着重于数据的传递，它并不能调用子组件里的属性和方法</p><p>2.后者着重于索引，主要用来调用子组件里的属性和方法。特别地，ref 用在 dom 元素的时候，能起到选择器的作用，这个功能比作为索引更加重要</p><hr><h4 id="emit-实现通信"><a href="#emit-实现通信" class="headerlink" title="$emit 实现通信"></a>$emit 实现通信</h4><p>上面两种方法主要都是父组件为主，给子组件信息，调用子组件的信息。<br>那么，第三种方法就是以子组件为主。<br>$emit 绑定一个自定义事件 event，当这个语句被执行的时候，就会将参数 arg 传递给父组件，父组件通过@event 监听并接收参数。</p><p><strong>father_emit.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> @<span class="attr">getMessage</span>=<span class="string">&quot;showMsg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;../components/child_emit.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Child</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    showMsg (title) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">title</span> = title</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>child_emit.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是子组件！<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mounted</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.$emit(<span class="string">&#x27;getMessage&#x27;</span>, <span class="string">&#x27;我是父组件！&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="三种方法区别"><a href="#三种方法区别" class="headerlink" title="三种方法区别"></a>三种方法区别</h4><p>1.对于 props，就是子组件设置一个 props，父组件给这个 props 赋值就可以通信，动态赋值可以用 v-bind（是主要的通信方式）</p><p>2.对于 ref，给子组件一个 ref，我们就可以通过这个<code>this.ref</code>，来调用子组件的属性和方法，这主要是用在 dom 树中，起到选择器的作用</p><p>3.对于$emit，子组件绑定一个方法和参数，父组件可以绑定子组件这个绑定方法的监听，获得子组件返回的参数。第三种方法少见一些。有些逆思维了。 目前不懂它存在的意义。</p><h3 id="混入-mixin"><a href="#混入-mixin" class="headerlink" title="混入 mixin"></a>混入 mixin</h3><p><strong>解释</strong></p><p>将组件的公共逻辑或者配置提取出来，哪个组件需要用到时，直接将提取的这部分混入到组件内部即可。这样既可以减少代码冗余度，也可以让后期维护起来更加容易。</p><p>这里需要注意的是：提取的是逻辑或配置，而不是 HTML 代码和 CSS 代码。换一种想法，mixin 就是组件中的组件，Vue 组件化让我们的代码复用性更高，那么组件与组件之间还有重复部分，我们使用 Mixin 在抽离一遍。</p><h4 id="Mixin-和-Vuex-的区别？"><a href="#Mixin-和-Vuex-的区别？" class="headerlink" title="Mixin 和 Vuex 的区别？"></a>Mixin 和 Vuex 的区别？</h4><p>上面一点说 Mixin 就是一个抽离公共部分的作用。在 Vue 中，Vuex 状态管理似乎也是做的这一件事，它也是将组件之间可能共享的数据抽离出来。两者看似一样，实则还是有细微的区别，区别如下：</p><ul><li>Vuex 公共状态管理，如果在一个组件中更改了 Vuex 中的某个数据，那么其它所有引用了 Vuex 中该数据的组件也会跟着变化。</li><li>Mixin 中的数据和方法都是独立的，组件之间使用后是互相不影响的。</li></ul><p><strong>功能</strong>:可以把个组件共用的配置提取成一个混入对象使用方式:<br>第一步定义混合,例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;...&#125;,</span><br><span class="line"><span class="attr">methods</span>:&#123;....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步使用混入,例如:</p><p>​ (1).全局混入: Vue.mixin(xxx)</p><p>​ (2).局部混入: mixins: [‘xxx’]</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>功能:用于增强 Vue<br>本质:包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据。</p><p>定义插件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue，options</span>) &#123;</span><br><span class="line"><span class="comment">//1.添加全局过滤器</span></span><br><span class="line">vue.<span class="title function_">filter</span>(....)</span><br><span class="line"><span class="comment">//2.添加全局指令</span></span><br><span class="line">vue.<span class="title function_">directive</span>(.. . .)</span><br><span class="line"><span class="comment">//3.配置全局混入(合)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(... .)</span><br><span class="line"><span class="comment">//4.添加实例方法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;...&#125;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用插件</strong>: <code>Vue.use()</code></p><h4 id="scoped-样式"><a href="#scoped-样式" class="headerlink" title="scoped 样式"></a>scoped 样式</h4><p>作用: 让样式在局部生效，防止冲突。</p><p>写法: <code>&lt;style scoped&gt;</code></p><h3 id="TodoList-案例总结"><a href="#TodoList-案例总结" class="headerlink" title="TodoList 案例总结"></a>TodoList 案例总结</h3><p>1.组件化编码流程:</p><p>​ (1).拆分静态组件:组件要按照功能点拆分，命名不要与 html 元素冲突。</p><p>​ (2).实现动态组件:考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用:</p><p>&nbsp;&nbsp;&nbsp;1).一个组件在用: 放在组件自身即可。</p><p>&nbsp;&nbsp;&nbsp;2).一些组件在用: 放在他们共同的父组件上(<strong>状态提升</strong>)。</p><p>​ (3).实现交互:从绑定事件开始。</p><p>2.props 适用于:</p><p>​ (1).父组件==&gt;子组件 通信</p><p>​ (2).子组件==&gt;父组件 通信(要求父先给子一个函数)</p><p>3.使用 v-model 时要切记: <strong>v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的！</strong></p><p>4.props 传过来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做。</p><h3 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h3><p>1.存储内容太小一般支持 5MB 左右(不同浏览器可能还不一样)</p><p>2.浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p><p>3.相关 APl:<br>&nbsp;&nbsp;1.<code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>&nbsp;&nbsp;该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。<br>&nbsp;&nbsp;2.<code>xxxxxStorage-getItem(&#39;person&#39;);</code><br>&nbsp;&nbsp;该方法接受一个键名作为参数，返回键名对应的值。<br>&nbsp;&nbsp;3.<code>xxxxxStorage.removeItem(&#39;key&#39;);</code><br>&nbsp;&nbsp;该方法接受一个键名作为参数，并把该键名从存储中删除。<br>&nbsp;&nbsp;4.<code>xxxxxStorage.clear()</code><br>&nbsp;&nbsp;该方法会清空存储中的所有数据。</p><p>4.<strong>备注</strong>:</p><p>​ 1.SessionStorage 存储的内容会随着浏览器窗口关闭而消失。</p><p>​ 2.LocalStorage 存储的内容，需要手动清除才会消失。</p><p>​ 3.<code>xxxxxStorage.getItem(xxx)</code> 如果 xxx 对应的 value 获取不到，那么 getltem 的返回值是 null</p><p>​ 4.<code>JSON.parse(nul1)</code>的结果依然是 null。</p><h3 id="组件自定义事件"><a href="#组件自定义事件" class="headerlink" title="组件自定义事件"></a>组件自定义事件</h3><p>1.子种组件间通信的方式，适用于:<strong>子组件</strong>===&gt;<strong>父组件</strong></p><p>⒉.使用场景: A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件（<strong>事件的回调在 A 中</strong>)。</p><p>3.绑定自定义事件:</p><p>​ (1).第一种方式，在父组件中: <code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>或<code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code><br>​ (2).第二种方式，在父组件中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Demo ref=&quot;demo&quot; /&gt;</span><br><span class="line">...... mounted()&#123; this.$refs.xxx.$on(&#x27;atguigu&#x27;,this.test) &#125;</span><br></pre></td></tr></table></figure><p>​ (3).若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p><p>4.触发自定义事件: <code>this.$emit(&#39;atguigu&#39;,数据)</code></p><p>5.解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p><p>6.组件上也可以绑定原生 DOM 事件，需要使用<code>native</code>修饰符。</p><p>7.<strong>注意</strong>:通过<code>this.refs.xxx.$on(&#39;atguigu&#39; ,回调)</code>绑定自定义事件时，回调<strong>要么配置在 methods 中，要么用箭头函数</strong>，否则 this 指向会出问题！！！</p><h3 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h3><p>1.—种组件间通信的方式，适用于<strong>任意组件间通信</strong>。</p><p>2.安装全局事件总线:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> / /安装全局事件总线，$bus就是当前应用的vm</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.使用事件总线 :</p><p>​ (1).接收数据: A 组件想接收数据，则在 A 组件中给$bus 绑定自定义事件，事件的<strong>回调留在 A 组件自身</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ (2).提供数据:<code>this.$bus.$emit( &#39;xxxx&#39;,数据)</code></p><p>4.最好在 beforeDestroy 钩子中，用$off 去解绑<strong>当前组件所用到的事件*</strong>。</p><h3 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h3><p>1.—种组件间通信的方式，适用于<strong>任意组件间通信</strong>。</p><p>2.使用步骤:</p><p>​ 1.安装 pubsub: <code>npm i pubsub-js</code><br>​ 2.引入: <code>import pubsub from &#39;pubsub-js&#39;</code><br>​ 3.接收数据:A 组件想接收数据，则在 A 组件中订阅消息，订阅的<strong>回调留在 A 组件自身</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)<span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.提供数据:<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p><p>5.最好在 beforeDestroy 钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color: red">取消订阅。</span></p><h4 id="nextTick（生命周期钩子）"><a href="#nextTick（生命周期钩子）" class="headerlink" title="nextTick（生命周期钩子）"></a>nextTick（生命周期钩子）</h4><p>1.语法: <code>this.$nextTick(回调函数)</code></p><p>2.作用: 在下一次 DOM 更新结束后执行其指定的回调。</p><p>3.什么时候用: 当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行。</p><p><a href="https://blog.csdn.net/zhouzuoluo/article/details/84752280">vue.nextTick()方法的使用详解（简单明了）</a></p><h3 id="过渡与动画"><a href="#过渡与动画" class="headerlink" title="过渡与动画"></a>过渡与动画</h3><p>1.作用: 在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名。</p><p>2.图示:<br><img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/9.webp" /> 3.写法:</p><p>​ 1.准备好样式:</p><p>​ (1).元素进入的样式:</p><p>​ &nbsp;​&nbsp;1.v-enter: 进入的起点</p><p>​ ​ &nbsp;​&nbsp;2.v-enter-active: 进入过程中</p><p>​ &nbsp;​&nbsp;3.v-enter-to: 进入的终点</p><p>​ (2).元素离开的样式:</p><p>​ ​ &nbsp;​&nbsp;1.v-leave: 离开的起点</p><p>​ ​ &nbsp;​&nbsp;2.v-leave-active: 离开过程中</p><p>​ ​ &nbsp;​&nbsp;3.v-leave-to: 离开的终点</p><p>​ 2.使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置 name 属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>你好啊!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​ 3.<strong>备注</strong>: 若有多个元素需要过度，则需要使用:<code>&lt;transition-group&gt;</code>，且每个元素都要指定 key 值。</p><h2 id="Vue-中的-ajax"><a href="#Vue-中的-ajax" class="headerlink" title="Vue 中的 ajax"></a>Vue 中的 ajax</h2><h3 id="vue-脚手架配置代理-开发环境-Ajax-跨域问题"><a href="#vue-脚手架配置代理-开发环境-Ajax-跨域问题" class="headerlink" title="vue 脚手架配置代理(开发环境 Ajax 跨域问题)"></a>vue 脚手架配置代理(开发环境 Ajax 跨域问题)</h3><p><strong>方法一</strong></p><p>在 vue.config.js 中添加如下配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">proxy</span>: <span class="string">&quot;http://localhost:5000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明:</p><p>​ 1.优点: 配置简单，请求资源时直接发给前端（8080）即可。</p><p>​ 2.缺点: 不能配置多个代理，不能灵活的控制请求是否走代理。</p><p>​ 3.工作方式: 若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配前端资源)</p><p><strong>方法二</strong></p><p>编写 vue.config.js 配置具体代理规则:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&quot;/api1&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">//匹配所有以&#x27;/api&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost:5000&quot;</span>, <span class="comment">//代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api1&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;/api2&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">//匹配所有以&#x27;/api&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost: 5001&quot;</span>, <span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api2&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">changeOrigin设置为true时，服务器收到的请求头中的host为: localhost: 5000</span></span><br><span class="line"><span class="comment">changeOrigin设置为false时，服务器收到的请求头中的host为: localhost:8080</span></span><br><span class="line"><span class="comment">changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明:</p><p>​ 1.优点: 可以配置多个代理，且可以灵活的控制请求是否走代理。</p><p>​ 2.缺点: 配置略微繁琐，请求资源时必须加前缀。</p><h3 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h3><p>1.作用: 让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于<strong>父组件===&gt;子组件</strong>。</p><p>2.分类: 默认插槽、具名插槽、作用域插槽</p><p>3.使用方式:</p><p>​ (1).默认插槽:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">父组件中:</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">子组件中:</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!--定义插槽--&gt;</span><br><span class="line">    &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>​</p><p>​ (2).具名插槽:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">父组件中:</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">&lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;template v-slot:footer&gt;</span><br><span class="line">&lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">子组件中:</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!--定义插槽--&gt;</span><br><span class="line">    &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>​ (3).作用域插槽:</p><p>​ 1).理解: 数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。(games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定）</p><p>​ 2).具体编码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">父组件中:</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!--生成的是ul列表--&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;g in scopeData.games&quot; : key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!--生成的是h4标题--&gt;</span><br><span class="line">&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">子组件中:</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Category&quot;,</span><br><span class="line">  props: [&quot;title&quot;],</span><br><span class="line">  //数据在子组件自身</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      games: [&quot;红色警戒&quot;, &quot;穿越火线&quot;, &quot;英雄联盟&quot;, &quot;超级玛丽&quot;],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应 用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方</p><p>式，且适用于任意组件间通信。</p><p><strong>为什么要使用 Vuex</strong></p><p>我们知道组件之间是独立存在的 组件之间要想实现通信 目前只有 props 选项 ，中大型项目时 面对一大堆组件之间的通信，与逻辑代码 将组件之间的共享数据给拿出来 在一定的规则下管理这些数据</p><p><strong>什么时候使用 Vuex？</strong></p><ol><li>多个组件依赖于同一状态</li><li>来自不同组件的行为需要变更同一状态</li></ol><h4 id="vuex-工作原理图"><a href="#vuex-工作原理图" class="headerlink" title="vuex 工作原理图"></a>vuex 工作原理图</h4><p><img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/8.webp" alt="vuex" style="zoom: 33%;" /></p><ul><li><strong>视图（View）</strong>，以声明方式将<strong>状态</strong>映射到视图；</li><li><strong>操作（Actions）</strong>，响应在<strong>视图</strong>上的用户输入导致的状态变化</li><li><strong>状态（State）</strong>，驱动应用的数据源</li></ul><h3 id="搭建-vuex-环境-store"><a href="#搭建-vuex-环境-store" class="headerlink" title="搭建 vuex 环境(store)"></a>搭建 vuex 环境(store)</h3><p>1.创建文件:<code>src/store/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="comment">//应用vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.在<code>main.js</code>中创建 vm 时传入<code>store</code>配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)，</span><br><span class="line">store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li>初始化数据、配置<code>actions</code> 、配置<code>mutations</code>，操作文件<code>store.js</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line"><span class="comment">//响应组件中加的动作</span></span><br><span class="line">    <span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line"><span class="comment">//console.log(&#x27;actions中的jia被调用了&#x27;,miniStore ,value)</span></span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">&#125;，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line"><span class="comment">//执行加</span></span><br><span class="line"><span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line"><span class="comment">//console.log(&#x27;mutations中的JIA被调用了&#x27; ,state,value)</span></span><br><span class="line">        state.<span class="property">sum</span> += value</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line"><span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations</span><br><span class="line">    state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li><p>组件中读取 vuex 中的数据:<code>$store.state.sum</code></p></li><li><p>组件中修改 vuex 中的数据:<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code>或<code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p></li></ol><blockquote><p><strong>备注</strong>:若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote><h3 id="getters-的使用"><a href="#getters-的使用" class="headerlink" title="getters 的使用"></a>getters 的使用</h3><ol><li><p>概念: 当 state 中的数据需要经过加正后再使用时，可以使用 getters 加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">......</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>组件中读取数据:<code>$store.getters.bigSum</code></li></ol><h3 id="四个-map-方法的使用"><a href="#四个-map-方法的使用" class="headerlink" title="四个 map 方法的使用"></a>四个 map 方法的使用</h3><p>1.<strong>mapState 方法</strong>: 用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line"><span class="comment">//借助mapState生成计算属性: sum、school、subject（对象写法)</span></span><br><span class="line">...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;)，</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapState生成计算属性: sum、school、subject（数组写法)</span></span><br><span class="line">...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>])，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<strong>mapGetters 方法</strong>: 用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line"><span class="comment">//借助mapGetters生成计算属性: bigSum(对象写法)</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">//借助mapGetters生成计算属性: bigSum(数组写法)</span></span><br><span class="line">...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<strong>mapActions 方法</strong>: 用于帮助我们生成与<code>actions</code>对话的方法，即:包含<code>$store.dispatch(xx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="comment">//靠mapActions生成: increment0dd、 incrementWait（对象形式)</span></span><br><span class="line">...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jia0dd&#x27;</span>,<span class="attr">incrementwait</span>:<span class="string">&#x27;jiawait&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">//靠mapActions生成: incrementOdd、incrementwait（数组形式)</span></span><br><span class="line">...<span class="title function_">mapActions</span>([<span class="string">&#x27;jia0dd&#x27;</span>,<span class="string">&#x27;jiawait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<strong>mapMutations 方法</strong>:用于帮助我们生成与<code>mutations</code>对话的方法，即:包含 <code>$store.commit(xx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="comment">//靠mapActions生成: increment、decrement（对象形式)</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapMutations生成:JIA、JIAN（对象形式)</span></span><br><span class="line">...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>])，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块化-命名空间"><a href="#模块化-命名空间" class="headerlink" title="模块化+命名空间*"></a>模块化+命名空间*</h3><p>1.目的: 让代码更好维护，让多种数据分类更加明确。</p><p>2.修改<code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line"><span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">    <span class="attr">state</span>:&#123; <span class="attr">x</span>:<span class="number">1</span> &#125;,</span><br><span class="line"><span class="attr">mutations</span>:&#123; ... &#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123; ... &#125;，</span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span>*<span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line"><span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">    <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line"><span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line"><span class="attr">modules</span>: &#123;</span><br><span class="line">countAbout,</span><br><span class="line">        personAbout</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.开启命名空间后，组件中读取 state 数据:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二:借助mapState读取:</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>])，</span><br></pre></td></tr></table></figure><p>4.开启命名空间后，组件中读取 getters 数据:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二:借助mapGetters读取;</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>, [<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure><p>5.开启命名空间后，组件中调用 dispatch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>, person)</span><br><span class="line"><span class="comment">//方式二，借助mapActions:</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>, <span class="attr">incrementwait</span>:<span class="string">&#x27;jiawait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>6.开启命名空间后，组件中调用 commit</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span> ,person)</span><br><span class="line"><span class="comment">//方式二:借助mapMutations:</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure><h3 id="vuex-核心概念和-API"><a href="#vuex-核心概念和-API" class="headerlink" title="vuex 核心概念和 API"></a>vuex 核心概念和 API</h3><p>各个类型的 API 各司其职，mutation 只管存，你给我（dispatch）我就存；action 只管中间处理，处理完我就给你，你怎么存我不管；Getter 我只管取，我不改的。action 放在了 methods 里面，说明我们应该把它当成函数来用（讲道理，钩子函数也应该可以的） mutation 是写在 store 里面的，这说明，它就是个半成品，中间量，我们不应该在外面去操作它。getter 写在了 computed 里面，这说明虽然 getter 我们写的是函数，但是我们应该把它当成计算属性来用。</p><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>1.vuex 管理的状态对象</p><p>2.是<strong>Vuex</strong>中的唯一数据源</p><p>3.只能通过 mutation 修改</p><p>4.示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">xxx.<span class="property">initValue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4><p>1.值为一个对象，包含多个响应用户动作的回调函数</p><p>2.通过 <code>commit()</code>来触发<code>mutation</code> 中函数的调用, 间接更新 state</p><p>3.如何触发 actions 中的回调？</p><p>​ 在组件中使用: <code>$store.dispatch(&#39;对应的 action 回调名&#39;)</code>触发</p><p>4.可以包含异步代码（定时器, ajax 等等）</p><p>5.示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="title function_">zzz</span>(<span class="params">&#123; commit, state &#125;, data1</span>) &#123;</span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&quot;yyy&quot;</span>, &#123; data1 &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><p>1.值是一个对象，包含多个直接更新 state 的方法</p><p>2.谁能调用 mutations 中的方法?如何调用?</p><p>​ 在 action 中使用: <code>commit(&#39;对应的 mutations 方法名&#39;)</code>触发</p><p>3.mutations 中方法的特点: 不能写异步代码、只能单纯的操作 state</p><p>4.示例代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">yyy (state，&#123;data1&#125;) &#123;</span><br><span class="line"><span class="comment">//更新state的某个属性</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>1.包含多个 module</p><p>2.一个 module 是一个 store 的配置对象</p><p>3.与一个组件（包含有共享数据）对应</p><h4 id="model"><a href="#model" class="headerlink" title="model*"></a>model*</h4><p><a href="https://vuex.vuejs.org/zh/guide/modules.html">Module | Vuex (vuejs.org)</a></p><p><a href="https://www.jianshu.com/p/a0c11ae01991">https://www.jianshu.com/p/a0c11ae01991</a></p><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="相关理解"><a href="#相关理解" class="headerlink" title="相关理解"></a>相关理解</h3><h4 id="vue-router-的理解"><a href="#vue-router-的理解" class="headerlink" title="vue-router 的理解"></a>vue-router 的理解</h4><p>vue 的一个插件库，专门用来实现 SPA 应用</p><h4 id="对-SPA-应用的理解"><a href="#对-SPA-应用的理解" class="headerlink" title="对 SPA 应用的理解"></a>对 SPA 应用的理解</h4><ol><li>单页 Web 应用（single page web application，SPA）。</li><li>整个应用只有<strong>一个完整的页面</strong>。</li><li>点击页面中的导航链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新</strong>。</li><li>数据需要通过 ajax 请求获取</li></ol><h3 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h3><h4 id="路由的理解"><a href="#路由的理解" class="headerlink" title="路由的理解"></a>路由的理解</h4><ol><li><p>什么是路由?</p><ol><li>一个路由就是 ─ 组映射关系(key - value)</li><li>key 为路径, value 可能是 function 或 component</li></ol></li><li><p>路由分类</p></li><li><p>后端路由:</p><ol><li><p>理解: value 是 function,用于处理客户端提交的请求。</p></li><li><p>工作过程: 服务器接收到一个请求时,根据<strong>请求路径</strong>找到匹配的<strong>函数</strong>来处理请求,返回响应数据。</p></li></ol></li><li><p>前端路由:</p><ol><li><p>理解: value 是 component，用于展示页面内容。</p></li><li><p>工作过程: 当浏览器的路径改变时,对应的组件就会显示。</p></li></ol></li></ol><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>1.安装 vue-router，命令:<code>npm i vue-router</code> 如果是 vue2 的话,命令后面加@3</p><p>2.应用插件:<code>Vue.use(VueRouter)</code></p><p>3.编写 router 配置项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="comment">//引入Luyou组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;../components/About&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;../ components /Home&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>4.实现切换(active-class 可配置高亮样式)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link active-<span class="keyword">class</span>=<span class="string">&quot;active&quot;</span> to=<span class="string">&quot;/about&quot;</span>&gt;</span><br><span class="line">  <span class="title class_">About</span></span><br><span class="line">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>5.指定展示位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h4 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h4><p>1.路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p><p>2.通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</p><p>3.每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</p><p>4.整个应用只有一个 router，可以通过组件的<code>$router</code>属性获取到。</p><h3 id="嵌套路由-多级路由"><a href="#嵌套路由-多级路由" class="headerlink" title="嵌套路由(多级路由)"></a>嵌套路由(多级路由)</h3><p>1.配置路由规则，使用 children 配置项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      <span class="comment">//通过children配置子级路由</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;news&quot;</span>, <span class="comment">//此处一定不要写:/news</span></span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">News</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;message&quot;</span>, <span class="comment">//此处一定不要写:/message</span></span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Message</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>2.跳转（要写完整路径)∶</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;/home/news&quot;</span>&gt;<span class="title class_">News</span>&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h3 id="路由的-query-参数"><a href="#路由的-query-参数" class="headerlink" title="路由的 query 参数"></a>路由的 query 参数</h3><p>1.传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;! --跳转并携带query参数，to的字符串写法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;/home/message/detail?id=666&amp;title=你好&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--跳转并携带query参数，to的对象写法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">path:&quot;</span>/<span class="attr">home</span>/<span class="attr">message</span>/<span class="attr">detail</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">query:</span>&#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">id:666</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">title:</span> &#x27;<span class="attr">你好</span>&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.接收参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span>;</span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span>;</span><br></pre></td></tr></table></figure><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>1.作用: 可以简化路由的跳转。</p><p>2.如何使用</p><p>​ 1.给路由命名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line">                <span class="attr">children</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;hello’//给路由命名</span></span><br><span class="line"><span class="string">                        path:&#x27;</span>welcome<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">component:Hello,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>2.简化跳转:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前,需要写完整的路径--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/demo/test/welcome&#x27;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">name : &quot;</span><span class="attr">hello</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">query:</span>&#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">id</span> <span class="attr">:666</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">title:</span>&#x27;<span class="attr">你好</span>&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="路由的-params-参数"><a href="#路由的-params-参数" class="headerlink" title="路由的 params 参数"></a>路由的 params 参数</h3><p>1.配置路由，声明接收 params 参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>: <span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>,<span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line"><span class="attr">component</span>: <span class="title class_">Detail</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--跳转并携带params参数，to的字符串写法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;/home/message/detail/666/你好&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--跳转并携带params参数，to的对象写法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">name:&#x27;xiangqing&#x27;,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">params:&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">id:666,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">title:&quot;</span><span class="attr">你好</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;”</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>特别注意: 路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置!</p></blockquote><p>3.接收参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span>;</span><br></pre></td></tr></table></figure><h3 id="路由的-props-配置"><a href="#路由的-props-配置" class="headerlink" title="路由的 props 配置"></a>路由的 props 配置</h3><p>作用: 让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"><span class="comment">//第一种写法: props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line"><span class="comment">//props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法: props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line"><span class="comment">//props:true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法:props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line"><span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line"><span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vue-路由传参的三种基本方式"><a href="#vue-路由传参的三种基本方式" class="headerlink" title="vue 路由传参的三种基本方式"></a><a href="https://www.jianshu.com/p/d276dcde6656">vue 路由传参的三种基本方式</a></h4><h3 id="路由传参相关面试题"><a href="#路由传参相关面试题" class="headerlink" title="路由传参相关面试题"></a>路由传参相关面试题</h3><p><strong>如何指定 params 参数可传可不传?</strong><br>如果路由要求传递 params 参数，但是你就不传递 params 参数，发现一件事情，URL 会有问题的<br>如何指定 params 参数可以传递、或者不传递，在配置路由的时候，在占位的后面加上一个问号【params 可以传递或者不传递】</p><p><strong>params 参数可以传递也可以不传递，但是如果传递是空串，如何解决?</strong></p><p>使用 undefined 解快: params 参数可以传递、不传递（空的字符串)</p><p><code>this.$router.push(&#123;name:&#39;search&#39; ,params:&#123; keyword : &quot; &quot;||undefined&#125; &#125;),</code></p><p><strong>路由组件可不可以传递 props 数据？</strong></p><p>可以，三种写法，在路由配置中，组件用 props 接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔值写法:params</span></span><br><span class="line"><span class="comment">//props:true,只能传params参数</span></span><br><span class="line"><span class="comment">//对象写法:额外的给路由组件传递一些props</span></span><br><span class="line"><span class="comment">//props:&#123;a: 1,b:2&#125;,</span></span><br><span class="line"><span class="comment">//函数写法:可以params参数、query参数，通过props传递给路由组件</span></span><br><span class="line"><span class="attr">props</span>:<span class="function">(<span class="params">$route</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span>·&#123;<span class="attr">keyword</span>:$route.<span class="property">params</span>.<span class="property">keyword</span> ,<span class="attr">k</span>:$route.<span class="property">query</span>.<span class="property">k</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lt-router-link-gt-的-replace-属性-无痕浏览-doge"><a href="#lt-router-link-gt-的-replace-属性-无痕浏览-doge" class="headerlink" title="&lt;router-link&gt;的 replace 属性(无痕浏览 doge)"></a><code>&lt;router-link&gt;</code>的 replace 属性(无痕浏览 doge)</h3><p>1.作用:控制路由跳转时操作浏览器历史记录的模式</p><p>⒉ 浏览器的历史记录有两种写入方式:分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></p><p>3.如何开启<code>replace</code>模式:<code>&lt;router-link replace ......&gt;News&lt;/router-link&gt;</code></p><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><p>1.作用:不借助<code>&lt;router-link&gt;</code>实现路由跳转，让路由跳转更加灵活</p><p>2.具体编码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiangqing&quot;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: xxx,</span><br><span class="line">    <span class="attr">title</span>: xxx,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiangqing&quot;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: xxx,</span><br><span class="line">    <span class="attr">title</span>: xxx,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>(); <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>(); <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(); <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure><h3 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h3><p>1.作用:让不展示的路由组件保持挂载，不被销毁。</p><p>2.具体编码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&quot;News(组件名)&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h3 id="两个新的生命周期钩子"><a href="#两个新的生命周期钩子" class="headerlink" title="两个新的生命周期钩子"></a>两个新的生命周期钩子</h3><p>1.作用: 路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</p><p>2.具体名字:</p><ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>作用: 对路由进行权限控制</p><h4 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫:初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line"><span class="title function_">next</span>()<span class="comment">//放行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&quot;)</span></span><br><span class="line"><span class="string">//next(&#123;name:&#x27;</span>guanyu<span class="string">&#x27;&#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;else&#123;</span></span><br><span class="line"><span class="string">next()//放行</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//全局后置守卫:初始化时执行、每次路由切换后执行</span></span><br><span class="line"><span class="string">router.afterEach((to,from)=&gt;&#123;</span></span><br><span class="line"><span class="string">if(to.meta.title)&#123;</span></span><br><span class="line"><span class="string">document.title = to.meta.title  //修改网页的title</span></span><br><span class="line"><span class="string">&#125;else&#123;</span></span><br><span class="line"><span class="string">document.title = &#x27;</span>vue_test<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="独享守卫"><a href="#独享守卫" class="headerlink" title="独享守卫"></a>独享守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">//next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组件内路由守卫"><a href="#组件内路由守卫" class="headerlink" title="组件内路由守卫"></a>组件内路由守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入守卫:通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to,<span class="keyword">from</span>,next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫:通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to,<span class="keyword">from</span>,next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由器的两种工作模式-hash-与-history"><a href="#路由器的两种工作模式-hash-与-history" class="headerlink" title="路由器的两种工作模式 hash 与 history"></a>路由器的两种工作模式 hash 与 history</h3><p>1.对于一个 url 来说，什么是 hash 值?——#及其后面的内容就是 hash 值。</p><p>2.hash 值不会包含在 HTTP 请求中，即: hash 值不会带给服务器。</p><p>3.hash 模式:</p><p>​ (1).地址中永远带着#号，不美观。</p><p>​ (2).若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法。</p><p>​ (3).兼容性较好。</p><p>​ (4).他虽然在 URL 中，但是不会被包括在 HTTP 请求当中 对后端完全没影响 因此改变 hash 不会重新加载页面</p><p>4.history 模式:</p><p>​ (1).地址干净，美观。</p><p>​ (2).兼容性和 hash 模式相比略差。</p><p>​ (3).应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题。</p><p>​ (4).当他修改执行时 虽然改变了当前的 URL 但游览器不会立即向后端发送请求</p><h3 id="前端路由原理解析与实现"><a href="#前端路由原理解析与实现" class="headerlink" title="前端路由原理解析与实现"></a>前端路由原理解析与实现</h3><p><strong>什么是前端路由 ？</strong></p><p>路由描述的是 URL 与 UI 之间的映射关系 这种映射是单向的 即 URL 变化引起的 UI 更新（无需刷新页面）</p><p><strong>如何实现前端路由？</strong></p><p>要实现前端路由需要解决两个核心</p><p>1.如何改变 URL 却不引起页面刷新</p><p>2.如何检测 URL 变化了</p><p>下面分别使用 hash 与 history 两种实现方式回答上面的两个核心问题</p><p><strong>hash 实现</strong></p><p>hash 是 url 中 hash（#）及后面的部分，常用作锚点在页面进行导航，改变 url 中的 hash 部分不会引起页面刷新</p><p>通过 hashchange 事件 监听 url 变化 改变 url 的方式只有这几种：通过游览器的前进后退 通过标签改变 url 通过 window.location 改变 URL 这几种情况改变 URL 都会触发 hashchange 事件</p><p><strong>history 实现</strong></p><p>history 提供了 pushState（增加状态）和 replaceState（改变状态）两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新</p><p>history 提供类似<code>hashchange</code> 事件的 popstate 事件 但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过<code>pushState/replaceState</code>或<code>&lt;a&gt;</code>标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 <code>pushState/replaceState</code>的调用和标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</p><h2 id="Vue-UI-组件库"><a href="#Vue-UI-组件库" class="headerlink" title="Vue UI 组件库"></a>Vue UI 组件库</h2><h3 id="移动端常用-UI-组件库"><a href="#移动端常用-UI-组件库" class="headerlink" title="移动端常用 UI 组件库"></a>移动端常用 UI 组件库</h3><ol><li>Vant <a href="https://youzan.github.io/vant">https://youzan.github.io/vant</a></li><li>Cube UI <a href="https://didi.github.io/cube-ui">https://didi.github.io/cube-ui</a></li><li>Mint UI <a href="http://mint-ui.github.io">http://mint-ui.github.io</a></li></ol><h3 id="PC-端常用-UI-组件库"><a href="#PC-端常用-UI-组件库" class="headerlink" title="PC 端常用 UI 组件库"></a>PC 端常用 UI 组件库</h3><ol><li>Element UI <a href="https://element.eleme.cn">https://element.eleme.cn</a></li><li>IView UI <a href="https://www.iviewui.co">https://www.iviewui.co</a>.</li></ol><h2 id="组件间通信高级"><a href="#组件间通信高级" class="headerlink" title="组件间通信高级*"></a>组件间通信高级*</h2><h3 id="1-事件注意事项"><a href="#1-事件注意事项" class="headerlink" title="1.事件注意事项"></a>1.事件注意事项</h3><p>事件：系统事件：click、双击、鼠标系列事件等等</p><p>​ 自定义事件</p><p>事件源、事件类型、事件回调</p><p>1、原生 DOM——button 标签可以绑定系统事件</p><p>2、组件标签——-可以绑定系统事件（不起作用：因为属于自定义事件）———@click 后面+ .native （可以把自定义事件变成原生的 DOM 事件）</p><p>原生 DOM click 事件，其实是给子组件的根节点绑定了单击事件——利用到事件委派</p><p>给原生 DOM 绑定自定义事件是没有任何意义的，因为没有办法触发$emit 函数</p><h3 id="2-v-model"><a href="#2-v-model" class="headerlink" title="2.v-model"></a>2.v-model</h3><p>【组件通信方式的一种】</p><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;深入v-model&lt;/h2&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;h2&gt;v-model实现原理（vue2)&lt;/h2&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">原生DOw当中是有oninput事件，它经常结合表单元素一起使用，当表单元素文本内容发生变化的时候就会发出发一次回调</span><br><span class="line">Vue2:可以通过value与input事件实现v-model功能</span><br><span class="line">:value 与 oninput 事件结合与 :v-model一样</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; :value=&quot;msg&quot; @input=&quot;msg = $event.target.value&quot; /&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;!--深入学习v-model：实现父子组件数据同步（实现父子组件通信） --&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">:value到底是什么？ props，父子组件通信</span><br><span class="line">@input到底是什么？ 并非原生DOM的input事件，属于自定义事件</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;CustomInput :value=&quot;msg&quot; @input=&quot;msg = $event&quot; /&gt;</span><br><span class="line">    &lt;!-- 简化写法 --&gt;</span><br><span class="line">    &lt;CustomInput v-model=&quot;msg&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &quot; ModelTest&#x27;,</span><br><span class="line">cmponents:&#123;</span><br><span class="line">CustomInput</span><br><span class="line">&#125;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">msg:&quot;我爱你塞北的大雪&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>CustomInput 组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;input包装组件&lt;/h2&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">:value   动态属性</span><br><span class="line">@input   给原生DOM绑定原生DOM事件</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      :value=&quot;value&quot;</span><br><span class="line">      @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &#x27;CustomInput&#x27;,</span><br><span class="line">props:[&#x27;value&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>v-model 实现原理：value 与 input 事件实现的，而且还需要注意可以通过 v-mode 实现父子组件数据同步</p><h3 id="3-sync-属性修饰符"><a href="#3-sync-属性修饰符" class="headerlink" title="3.sync 属性修饰符"></a>3.sync 属性修饰符</h3><p>【组件通信方式的一种】</p><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    小明的爸爸现在有&#123;&#123; money &#125;&#125;元</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;不使用sync修改符&lt;/h2&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">:money父组件给子组件传递props</span><br><span class="line">@update:money给子组件绑定的自定义事件只不过名字叫做update:money</span><br><span class="line">目前现在这种操作，起始和v-model很相似,可以实现父子组件数据同步</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;Child :money=&quot;money&quot; @update:money=&quot;money = $event&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;使用sync修改符&lt;/h2&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">:money.sync:  </span><br><span class="line">第一，父组件给字符串传递props money</span><br><span class="line">第二，给当前子组件绑定了一个自定义事件,而且事件名称即为update:money</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;Child2 :money.sync=&quot;money&quot; /&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">import Child2 from &#x27;./Child2.vue&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;&#x27;,</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">money : 10000</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">Child,</span><br><span class="line">        Child2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Child 组件（两个组件一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;小明每次花100元&lt;/span&gt;</span><br><span class="line">    &lt;button @click=&quot;$emit(&#x27;update:money&#x27;, money - 100)&quot;&gt;花钱&lt;/button&gt;</span><br><span class="line">    爸爸还剩&#123;&#123; money &#125;&#125;元</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;child&#x27;,</span><br><span class="line">props: [&#x27;money&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="4-attrs-与-listeners"><a href="#4-attrs-与-listeners" class="headerlink" title="4. $attrs 与 $listeners"></a>4. <code>$attrs</code> 与 <code>$listeners</code></h3><p><code>$attrs</code>属于组件的一个属性，可以获取到父组件传递过来的 props 数据，对于子组件而言，父组件给的数据可以利用 props 接收，如果子组件通过 props 接收的属性，在$attrs 属性当中是获取不到的</p><p>$listeners 也是组件实例自身的一个属性，他可以获取到父组件给子组件传递的自定义事件</p><p>按钮想要增加鼠标放上去的提示信息，外面加一个 a 标签，:title 属性为提示信息</p><h3 id="5-children与-parent"><a href="#5-children与-parent" class="headerlink" title="5.$children与$parent"></a>5.<code>$children</code>与<code>$parent</code></h3><p>建议用 ref ,直接获取相应的子组件</p><p>$children 是组件实例的属性，可以获取到当前组件的全部子组件【是个数组】</p><p>不要用$children[0]书写，如果子组件过多，第 0 项可能不是想要的组件</p><p>$parent 可以获取到某个组件的父组件，可以操作父组件的数据和方法</p><h3 id="6-混入-mixin"><a href="#6-混入-mixin" class="headerlink" title="6.混入 mixin"></a>6.混入 mixin</h3><p>如果项目当中出现很多结构类似功能，想到组件复用</p><p>如果项目当中很多的组件 JS 业务逻辑相似，想到 mixin【可以把多个组件 JS 部分重复、相似地方】</p><h3 id="7-插槽"><a href="#7-插槽" class="headerlink" title="7.插槽"></a>7.插槽</h3><p>可以实现父子组件通信（通信的结构）</p><p>默认插槽</p><p>具名插槽</p><p>作用域插槽：子组件的数据来源于父组件，子组件是决定不了自身结构与外观</p>]]></content>
    
    
    <summary type="html">Vue2知识整理</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="vue" scheme="https://munanchun.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://munanchun.github.io/posts/54b11a0c.html"/>
    <id>https://munanchun.github.io/posts/54b11a0c.html</id>
    <published>2023-01-08T11:57:00.000Z</published>
    <updated>2023-01-08T11:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise-的理解和使用"><a href="#Promise-的理解和使用" class="headerlink" title="Promise 的理解和使用"></a>Promise 的理解和使用</h2><h3 id="Promise-是什么"><a href="#Promise-是什么" class="headerlink" title="Promise 是什么?"></a>Promise 是什么?</h3><p><strong>抽象表达:</strong></p><ol><li><p>Promise 是一门新的技术(ES6 规范)</p></li><li><p>Promise 是 JS 中进行异步编程的新解决方案</p></li></ol><p>​ 备注：旧方案是单纯使用回调函数</p><p><strong>具体表达:</strong></p><ol><li><p>从语法上来说: Promise 是一个构造函数</p></li><li><p>从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值</p></li></ol><h4 id="promise-的状态改变"><a href="#promise-的状态改变" class="headerlink" title="promise 的状态改变"></a>promise 的状态改变</h4><ol><li><p>pending 变为 resolved</p></li><li><p>pending 变为 rejected</p><p>说明: 只有这 2 种, 且一个 promise 对象只能改变一次 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</p></li></ol><h4 id="promise-的基本流程"><a href="#promise-的基本流程" class="headerlink" title="promise 的基本流程"></a>promise 的基本流程</h4><p><img src="https://fastly.jsdelivr.net/gh/1405720461/blog_img@main/study/2.webp"  style="zoom:67%;" /></p><h4 id="promise-的基本使用"><a href="#promise-的基本使用" class="headerlink" title="promise 的基本使用"></a>promise 的基本使用</h4><ol><li>使用 1: 基本编码流程</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 1) 创建 promise 对象(pending 状态), 指定执行器函数 const p = new</span></span><br><span class="line">  <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;<span class="string">&quot; &quot;</span>&#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 2) 在执行器函数中启动异步任务</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="comment">// 3) 根据结果做不同处理</span></span><br><span class="line">      <span class="comment">// 3.1) 如果成功了, 调用 resolve(), 指定成功的 value, 变为 resolved 状态</span></span><br><span class="line">      <span class="keyword">if</span> (time % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;成功的值 &quot;</span> + time);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.2) 如果失败了, 调用 reject(), 指定失败的 reason, 变为rejected 状态</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;失败的值&quot;</span> + time);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ) <span class="comment">// 4) 能 promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason p.then(</span></span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    <span class="comment">// 成功的回调函数 onResolved, 得到成功的 vlaue</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功的 value: &quot;</span>, value)</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 失败的回调函数 onRejected, 得到失败的 reason</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败的 reason: &quot;</span>, reason)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>使用 2: 使用 promise 封装基于定时器的异步</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doDelay</span>(<span class="params">time</span>) &#123;</span><br><span class="line"><span class="comment">// 1. 创建 promise 对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 2. 启动异步任务</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;启动异步任务&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;延迟任务开始执行...&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 假设: 时间为奇数代表成功, 为偶数代表失败</span></span><br><span class="line"><span class="keyword">if</span> (time %<span class="number">2</span>=== <span class="number">1</span>) &#123; <span class="comment">// 成功了</span></span><br><span class="line"><span class="comment">// 3. 1. 如果成功了, 调用 resolve()并传入成功的 value</span></span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;成功的数据 &#x27;</span> + time)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 失败了</span></span><br><span class="line"><span class="comment">// 3.2. 如果失败了, 调用 reject()并传入失败的 reason</span></span><br><span class="line"><span class="title function_">reject</span>(<span class="string">&#x27;失败的数据 &#x27;</span> + time)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">doDelay</span>(<span class="number">2000</span>)</span><br><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的 value: &#x27;</span>, value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的 reason: &#x27;</span>, reason)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>使用 3: 使用 promise 封装 ajax 异步请求</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可复用的发 ajax 请求的函数: xhr + promise</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseAjax</span>(<span class="params">url</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (xhr.<span class="property">readyState</span>!==<span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">const</span> &#123;status, response&#125; = xhr</span><br><span class="line"><span class="comment">// 请求成功, 调用 resolve(value)</span></span><br><span class="line"><span class="keyword">if</span> (status&gt;=<span class="number">200</span> &amp;&amp; status&lt;<span class="number">300</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(response))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 请求失败, 调用 reject(reason)</span></span><br><span class="line"><span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败: status: &#x27;</span> + status))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">promiseAjax</span>(<span class="string">&#x27;https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=video&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line"><span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;显示成功数据&#x27;</span>, data)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(error.<span class="property">message</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="为什么要用-Promise"><a href="#为什么要用-Promise" class="headerlink" title="为什么要用 Promise?"></a>为什么要用 Promise?</h3><h4 id="指定回调函数的方式更加灵活"><a href="#指定回调函数的方式更加灵活" class="headerlink" title="指定回调函数的方式更加灵活"></a>指定回调函数的方式更加灵活</h4><ol><li>旧的: 必须在启动异步任务前指定</li><li>promise: 启动异步任务 =&gt; 返回 promie 对象 =&gt; 给 promise 对象绑定回调函数(甚至可以在异步任务结束后指定/多个)</li></ol><h4 id="支持链式调用-可以解决回调地狱问题"><a href="#支持链式调用-可以解决回调地狱问题" class="headerlink" title="支持链式调用, 可以解决回调地狱问题*"></a>支持链式调用, 可以解决回调地狱问题*</h4><ol><li><p>什么是回调地狱?</p><p>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p></li><li><p>回调地狱的缺点?</p><p>不便于阅读 不便于异常处理</p></li><li><p>解决方案?</p><p>promise 链式调用</p></li><li><p>终极解决方案?</p><p>async/await</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 成功的回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">successCallback</span>(<span class="params">result</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;声音文件创建成功: &quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 失败的回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">failureCallback</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;声音文件创建失败: &quot;</span> + error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.1 使用纯回调函数 */</span></span><br><span class="line"><span class="title function_">createAudioFileAsync</span>(audioSettings, successCallback, failureCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.2. 使用 Promise */</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">createAudioFileAsync</span>(audioSettings); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">promise.<span class="title function_">then</span>(successCallback, failureCallback);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.1. 回调地狱*/</span></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line"><span class="title function_">doSomethingElse</span>(result, <span class="keyword">function</span>(<span class="params">newResult</span>) &#123;</span><br><span class="line"><span class="title function_">doThirdThing</span>(newResult, <span class="keyword">function</span>(<span class="params">finalResult</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult)</span><br><span class="line">&#125;, failureCallback)</span><br><span class="line">&#125;, failureCallback)</span><br><span class="line">&#125;, failureCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.2. 使用 promise 的链式调用解决回调地狱*/</span></span><br><span class="line"><span class="title function_">doSomething</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">doSomethingElse</span>(result)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">newResult</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">doThirdThing</span>(newResult)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">finalResult</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(failureCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.3. async/await: 回调地狱的终极解决方案*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">doSomething</span>()</span><br><span class="line"><span class="keyword">const</span> newResult = <span class="keyword">await</span> <span class="title function_">doSomethingElse</span>(result)</span><br><span class="line"><span class="keyword">const</span> finalResult = <span class="keyword">await</span> <span class="title function_">doThirdThing</span>(newResult)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"><span class="title function_">failureCallback</span>(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="如何使用-Promise"><a href="#如何使用-Promise" class="headerlink" title="如何使用 Promise?"></a>如何使用 Promise?</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ol><li><p>Promise 构造函数: Promise (excutor) {}</p><p>(1) executor 函数: 执行器 (resolve, reject) =&gt; {}</p><p>(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}</p><p>(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}</p><p>说明: executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行</p></li><li><p>Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}</p><p>(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}</p><p>(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p><p>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p></li><li><p>Promise.prototype.catch 方法: (onRejected) =&gt; {}</p><p>(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p><p>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p></li><li><p>Promise.resolve 方法: (value) =&gt; {}</p><p>(1) value: 成功的数据或 promise 对象</p><p>说明: 返回一个成功/失败的 promise 对象</p></li><li><p>Promise.reject 方法: (reason) =&gt; {}</p><p>(1) reason: 失败的原因</p><p>说明: 返回一个失败的 promise 对象</p></li><li><p>Promise.all 方法: (promises) =&gt; {}</p><p>(1) promises: 包含 n 个 promise 的数组</p><p>说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就 直接失败</p></li><li><p>Promise.race 方法: (promises) =&gt; {}</p><p>(1) promises: 包含 n 个 promise 的数组</p><p>说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态</p></li></ol><h4 id="promise-的几个关键问题"><a href="#promise-的几个关键问题" class="headerlink" title="promise 的几个关键问题"></a>promise 的几个关键问题</h4><ol><li><p>如何改变 promise 的状态?</p><p>(1) resolve(value): 如果当前是 pending 就会变为 resolved</p><p>(2) reject(reason): 如果当前是 pending 就会变为 rejected</p><p>(3) 抛出异常: 如果当前是 pending 就会变为 rejected</p></li><li><p>一个 promise 指定多个成功/失败回调函数, 都会调用吗?</p><p>当 promise 改变为对应状态时都会调用</p></li><li><p>改变 promise 状态和指定回调函数谁先谁后?</p><p>(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</p><p>(2) 如何先改状态再指定回调?</p><p>​ ① 在执行器中直接调用 resolve()/reject()</p><p>​ ② 延迟更长时间才调用 then()</p><p>(3) 什么时候才能得到数据?</p><p>​ ① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</p><p>​ ② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p></li><li><p>promise.then()返回的新 promise 的结果状态由什么决定?</p><p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定</p><p>(2) 详细表达:</p><p>​ ① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常</p><p>​ ② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</p><p>​ ③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p></li><li><p>promise 如何串连多个操作任务?</p><p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用</p><p>(2) 通过 then 的链式调用串连多个同步/异步任务</p></li><li><p>promise 异常传透?</p><p>(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,</p><p>(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理</p></li><li><p>中断 promise 链?</p><p>(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</p><p>(2) 办法: 在回调函数中返回一个 pendding 状态的 promise 对象</p></li></ol>]]></content>
    
    
    <summary type="html">Promise</summary>
    
    
    
    <category term="前端" scheme="https://munanchun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://munanchun.github.io/tags/js/"/>
    
    <category term="promise" scheme="https://munanchun.github.io/tags/promise/"/>
    
  </entry>
  
</feed>
